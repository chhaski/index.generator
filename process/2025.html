<!DOCTYPE html>
<html lang="en">

<head>
      <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Index.Training</title>
  <link rel="icon" type="image/x-icon" href="../SYSED002.ICO">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            font-family: Arial, sans-serif;
            background: #fafafa;
            position: relative;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }



        canvas {
            display: block;
            width: 100%;
            height: 100%;
            filter: blur(0.5px);
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }
        .glassy-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.4;
            background-image: 
                repeating-linear-gradient(
                    45deg, 
                    transparent, 
                    transparent 8px, 
                    rgba(255,255,255,0.25) 8px, 
                    rgba(255,255,255,0.25) 16px
                ),
                repeating-linear-gradient(
                    -45deg, 
                    transparent, 
                    transparent 8px, 
                    rgba(255,255,255,0.2) 8px, 
                    rgba(255,255,255,0.2) 16px
                );
            filter: blur(4px);
            z-index: 9999;
        }

        .diffused-texture {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
            background-image: 
                repeating-linear-gradient(
                    0deg, 
                    transparent, 
                    transparent 4px, 
                    rgba(255,255,255,0.15) 4px, 
                    rgba(255,255,255,0.15) 8px
                );
            filter: blur(6px);
            z-index: 9998;
        }

        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #1f2937;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 6px 10px;
            display: none;
            border-radius: 0;
            font-size: 12px;
            font-weight: 500;
            font-family: Arial, sans-serif;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.6);
            max-width: 300px;
            line-height: 1.3;
            z-index: 10000;
        }

        .entry {
            position: fixed;
            color: #1f2937;
            background: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 4px 8px;
            cursor: pointer;
            border-radius: 0;
            font-size: 14px;
            font-weight: 400;
            font-family: Arial, sans-serif;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease;
            line-height: 1.2;
            max-width: 280px;
            z-index: 10000;
        }
        
        .entry:hover {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.12);
            transform: translateY(-1px);
        }



        .legend-item {
            display: inline-block;
            margin-bottom: 5px;

        }

        .legend-symbol {
            color: white;
            background-color: rgba(0, 0, 0, 0.5);
            margin-right: 5px;
            font-weight: bold;
        }

        .legend-title {
            font-size: 0.8em;
        }

        .header {
            position: absolute;
            top: 0;
            width: 100%;
            color: black;
            text-align: center;
            font-size: 30px;
            pointer-events: none;
            z-index: 10000;
        }

        .centerheader {
            position: absolute;
            top: 10px;
            width: 100%;
            color: #444;
            text-align: center;
            font-size: 13px;
            pointer-events: none;
            z-index: 10000;
        }

        .header .subheader {
            font-size: 20px;
        }

        .header .link {
            font-size: 15px;
        }

        .top-left {
            position: absolute;
            top: 10px;
            left: 10px;
            text-align: left;
            color: #444;
            z-index: 10000;
        }
        


        .top-right {
            position: absolute;
            top: 10px;
            right: 10px;
            text-align: right;
            z-index: 10000;
        }
        
        /* View Switcher */
        .view-switcher {
            position: absolute;
            top: 50px;
            right: 10px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .view-btn {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(0, 0, 0, 0.2);
            padding: 8px 12px;
            cursor: pointer;
            font-size: 11px;
            font-family: Arial, sans-serif;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .view-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
        }

        .view-btn.active {
            background: rgba(0, 0, 0, 0.8);
            color: white;
        }

        /* Text Ocean View */
        .text-ocean {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: #ffffff;
            z-index: 1;
        }

        .text-ocean.active {
            display: block;
        }

        .text-container {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            transform: translateZ(0);
            will-change: transform;
        }

        .text-item {
            position: absolute;
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            font-weight: normal;
            color: #ff0000;
            background: #ffff00;
            padding: 2px 4px;
            white-space: nowrap;
            will-change: transform;
            transform: translateZ(0);
            line-height: 1;
            letter-spacing: 0;
        }

        /* 3D Scene */
        .scene-3d {
            display: block;
        }

        /* ASCII Background Layer */
        .ascii-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Behind text constellation */
            pointer-events: none; /* Non-interactive */
            display: none; /* Hidden by default */
        }

        /* Text Constellation Layer */
        .text-constellation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* Above ASCII background */
            pointer-events: all; /* Interactive */
            display: block; /* Visible by default */
        }

        /* Selection Panel (floating on right side) */
        .selection-panel {
            position: fixed;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            width: 300px;
            max-height: 500px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            padding: 20px;
            z-index: 10000;
            display: none;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }

        /* Gradient background for sidebar */
        .selection-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, transparent 0%, rgba(255, 255, 255, 0.2) 30%, rgba(255, 255, 255, 0.6) 70%, rgba(255, 255, 255, 0.9) 100%);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: -1;
            pointer-events: none;
        }

        .selection-left {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .selection-right {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
        }

        .current-entry {
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #8b00ff;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(139, 0, 255, 0.2);
            display: flex !important;
            flex-direction: row !important; /* Force horizontal layout */
            gap: 15px;
            align-items: flex-start; /* Align to top for better text layout */
            position: relative;
            width: calc(100% - 40px); /* Account for sidebar padding */
            min-width: 0; /* Allow content to shrink */
            overflow: visible; /* Prevent text cutoff */
        }

        .current-entry-book {
            width: 60px;
            height: 90px;
            border-radius: 4px;
            overflow: hidden;
            border: 2px solid #8b00ff;
            flex-shrink: 0 !important;
            flex-grow: 0 !important;
            order: 1 !important; /* Force book to come first */
        }

        .current-entry-book img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .current-entry-content {
            flex: 1 !important;
            min-width: 0; /* Allow text to wrap properly */
            overflow: visible; /* Ensure text isn't clipped */
            word-wrap: break-word; /* Break long words if needed */
            order: 2 !important; /* Force content to come after book */
            display: block !important; /* Ensure text content doesn't create nested flex */
        }

        .sidebar-section-title {
            display: none; /* Hide Currently Selected title */
        }

        .current-entry-title {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
            color: #333;
            display: block !important;
        }

        .current-entry-text {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.4;
            color: #666;
            display: block !important;
            margin: 0;
        }

        .selection-bar.active {
            display: flex;
        }

        .selection-bar-label {
            display: none; /* Remove the "Selected" label */
        }

        .selection-items {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 30px; /* Increased gap to fill width better */
            width: calc(100% - 40px); /* Match main card width accounting for padding */
            justify-content: space-between;
        }

        .selection-item {
            position: relative;
            width: 100%;
            max-width: 100px;
            height: 150px;
            border-radius: 8px;
            overflow: visible; /* Allow badges to show outside */
            cursor: pointer;
            transition: all 0.3s ease;
            border: 3px solid #8b00ff;
            box-shadow: 0 4px 12px rgba(139, 0, 255, 0.2);
            z-index: 2;
            background: white;
        }

        .selection-item-cover-container {
            width: 100%;
            height: 100%;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .selection-item:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(139, 0, 255, 0.3);
        }

        .selection-item-cover {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .selection-item-overlay {
            position: absolute;
            bottom: -15px; /* Sit halfway below the book edge */
            left: 50%;
            transform: translateX(-50%);
            width: 80%; /* Smaller than book width for badge effect */
            height: 30px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            border: 2px solid #8b00ff;
            border-radius: 15px; /* Pill shape for badge */
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 2px 8px;
            z-index: 3;
            box-shadow: 0 2px 8px rgba(139, 0, 255, 0.3);
        }

        .selection-item-text {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
            font-size: 8px;
            font-weight: bold;
            line-height: 1.1;
            max-height: 100%;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 1; /* Single line for badge */
            -webkit-box-orient: vertical;
            white-space: nowrap;
        }



        .selection-items::-webkit-scrollbar {
            height: 4px;
        }

        .selection-items::-webkit-scrollbar-track {
            background: transparent;
        }

        .selection-items::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 2px;
        }
        





        /* Right Panel (VStack of containers) */
        .right-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            bottom: 100px;
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            z-index: 10000;
        }
        /* Left panel should mirror right panel dimensions */
        #left-panel.right-panel {
            left: 20px;
            right: auto;
            top: 20px;
            bottom: 100px;
            width: 280px;
        }

        .panel-container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            font-family: Arial, sans-serif;
            text-align: center; /* Center text within panels */
        }

        .panel-container h4 {
            margin: 0 0 12px 0;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        /* Opacity Control Panel (part of right panel) */
        .opacity-controls {
            /* Inherits from .panel-container */
            display: block;
        }

        .opacity-controls h4 {
            margin: 0 0 12px 0;
            font-size: 12px;
            font-weight: bold;
            color: #333;
            text-align: center;
        }

        .opacity-control {
            margin-bottom: 12px;
        }

        .opacity-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
            display: block;
        }

        .opacity-slider {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            cursor: pointer;
        }

        .opacity-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #8b00ff;
            border-radius: 50%;
            cursor: pointer;
        }

        .opacity-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #8b00ff;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .opacity-value {
            font-size: 10px;
            color: #999;
            float: right;
        }

        /* Right Panel additional containers */
        .item-info {
            margin-bottom: 15px;
        }

        .item-title {
            font-weight: bold;
            margin-bottom: 5px;
            color: #333;
        }

        .item-book {
            font-size: 12px;
            color: #666;
            padding: 5px;
            border-left: 3px solid #ddd;
            background-color: rgba(0,0,0,0.02);
        }

        .clickable-items {
            max-height: 150px;
            overflow-y: auto;
        }

        .clickable-item {
            padding: 4px 0;
            margin: 4px 0;
            background: transparent;
            border-radius: 0;
            cursor: pointer;
            font-size: 12px;
            transition: color 0.15s ease, opacity 0.15s ease;
            text-align: left;
            display: block;
            color: rgba(26, 13, 171, 0.85); /* softened classic link blue */
            text-decoration: underline;
        }

        .clickable-item:hover {
            background: transparent;
            color: rgba(85, 26, 139, 0.9); /* softened hover purple */
            text-decoration-thickness: from-font;
        }

        .no-items {
            padding: 8px;
            color: #999;
            font-style: italic;
            font-size: 12px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Color-coded reference items to match connection line colors */
        .parent-item {
            border-left: 4px solid #3b82f6; /* Blue for parent */
            background: rgba(59, 130, 246, 0.1);
            padding-left: 12px;
        }
        
        .see-item {
            border-left: 4px solid #10b981; /* Green for see */
            background: rgba(16, 185, 129, 0.1);
            padding-left: 12px;
        }
        
        .see-also-item {
            border-left: 4px solid #f59e0b; /* Orange for see also */
            background: rgba(245, 158, 11, 0.1);
            padding-left: 12px;
        }
        
        /* Reference Tree Tokens */
        :root {
            --tree-text: #2b2b2b;
            --tree-subtle: #6b6b6b;
            --tree-hairline: #e6e6e6;
            --tree-parent: #3b82f6;
            --tree-children: #8b5cf6;
            --tree-see: #10b981;
            --tree-see-also: #f59e0b;
            --tree-hover-bg: rgba(0,0,0,0.04);
            --tree-focus: #1a73e8;
        }

        /* Hierarchical Reference Tree Styles */
        .reference-tree {
            margin-top: 15px;
            font-family: inherit;
            font-size: 12px;
            line-height: 1.35;
            color: var(--tree-text);
            position: relative;
            padding-left: 20px;
        }
        
        .tree-item {
            position: relative;
            margin: 2px 0;
            padding: 6px 8px 6px 0;
            border-radius: 4px;
            transition: background-color 0.12s ease;
            margin-left: 12px;
        }
        
        .tree-item:hover {
            background: var(--tree-hover-bg);
        }
        
        /* Connection lines for tree items (disabled for minimal look; children use custom connectors) */
        .tree-item::before { content: none; }
        
        .tree-section {
            margin: 16px 0;
            position: relative;
            padding-left: 12px; /* tighter to align tree visually */
        }

        /* Index-style indentation rules */
        .tree-parent,
        .tree-current,
        .tree-see,
        .tree-see-also {
            padding-left: 0; /* Unindented sections */
        }

        .tree-parent .tree-item,
        .tree-current .tree-item,
        .tree-see .tree-item,
        .tree-see-also .tree-item {
            margin-left: 0; /* Unindented items */
        }

        .tree-children {
            position: relative;
            padding-left: 16px; /* Slight indent for children section */
        }

        /* Global indentation helper */
        .tree-item.tree-indented { margin-left: 12px; }

        /* Children respect type-based indentation */
        .tree-children .tree-item { margin-left: 0; }
        .tree-children .tree-item.tree-indented { margin-left: 12px; }

        /* Remove vertical rails anywhere (children, nested, etc.) */
        .tree-children::before { content: none; }

        .tree-children .tree-item::after { content: none; }

        /* Single elbow rule: show a grey elbow only when an item is indented */
        .tree-item.tree-indented::before {
            content: '';
            position: absolute;
            left: -16px;
            top: 50%;
            width: 16px;
            height: 2px;
            transform: translateY(-50%);
        }
        
        .tree-section-label {
            font-weight: 600;
            margin-bottom: 4px;
            padding: 0;
            border-radius: 0;
            font-size: 10px; /* smaller label */
            text-transform: none; /* not all caps */
            letter-spacing: 0.02em;
            position: relative;
            color: var(--tree-subtle);
            text-align: right; /* right aligned labels */
        }

        /* Hide redundant "Current Selection" label */
        .tree-current .tree-section-label { display: block; }
        
        /* Minimal horizontal connectors are added only for children items; section line removed */
        .tree-section::before { content: none; }
        
        #from-book-container .book-info {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        #from-book-container .book-cover-display { display: none; }
        #from-book-container .book-text {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            text-align: left;
        }
        #from-book-container .book-title {
            font-weight: 600;
            color: #333;
            font-size: 12px;
            line-height: 1.3;
        }
        #from-book-container .book-author {
            color: var(--tree-subtle);
            font-size: 11px;
            line-height: 1.2;
            margin-top: 2px;
        }

        .tree-parent,
        .tree-see,
        .tree-see-also,
        .tree-children {
            border-left-color: transparent;
            background: transparent;
        }

        /* Remove color-coded label backgrounds */
        .tree-parent .tree-section-label,
        .tree-see .tree-section-label,
        .tree-see-also .tree-section-label,
        .tree-children .tree-section-label { background: transparent; color: var(--tree-subtle); }

        /* Children connectors in purple (horizontal ticks) */
        .tree-children::before { content: none; }
        .tree-children .tree-item::after { background: var(--tree-children); }

        /* Neutralize left-color indicators for category items */
        .tree-parent .tree-item,
        .tree-see .tree-item,
        .tree-see-also .tree-item,
        .tree-children .tree-item { border-left-color: transparent; }
        
        .tree-connected-item {
            border-left: 4px solid #6b7280; /* Gray for general connected items */
            background: rgba(107, 114, 128, 0.1);
            padding-left: 12px;
        }
        
        .tree-item-content {
            font-weight: 500;
            color: #333;
            display: flex;
            align-items: center;
            justify-content: flex-start; /* Left-align content for index-style layout */
            text-align: left; /* Left-align text */
        }
        
        .tree-item-text {
            flex: 1;
            cursor: pointer;
            z-index: 1;
            position: relative;
            text-align: left; /* Left-align text within the tree item */
            color: rgba(26, 13, 171, 0.85);
            text-decoration: underline;
        }
        
        .tree-item-actions {
            display: flex;
            align-items: center;
            opacity: 0;
            transition: opacity 0.12s ease;
        }
        
        .tree-item:hover .tree-item-actions,
        .tree-item:focus-within .tree-item-actions {
            opacity: 1;
        }
        
        .magnify-btn { display: none; }
        
        .magnify-btn:hover {
            background: #f9f9f9;
            border-color: #d0d0d0;
        }
        .magnify-btn:focus-visible {
            outline: 2px solid var(--tree-focus);
            outline-offset: 2px;
        }
        
        
        
        .tree-nested {
            margin-left: 0;
            position: relative;
            border-left: 0;
            padding-left: 0;
            margin-top: 8px;
        }
        
        .tree-nested::before { content: none; }
        
        .tree-nested .tree-item {
            margin-left: 0;
        }
        
        .tree-nested .tree-item::before { content: none; }
        
        .tree-sub-section {
            margin: 8px 0;
            font-size: 10px;
            position: relative;
        }
        
        .tree-sub-label {
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            background: rgba(255,255,255,0.8);
            padding: 2px 6px;
            border-radius: 3px;
            display: inline-block;
            border: 1px solid #e0e0e0;
        }
        
        .tree-deep {
            margin-left: 0px;
            border-left: 2px dashed #d0d0d0;
            padding-left: 12px;
            position: relative;
        }
        
        .tree-deep::before {
            content: '';
            position: absolute;
            left: -2px;
            top: -4px;
            width: 2px;
            height: 8px;
            background: #d0d0d0;
        }
        
        .tree-deep .tree-item {
            margin: 4px 0;
            padding: 6px 8px;
            font-size: 11px;
            margin-left: 0;
        }
        
        .tree-deep .tree-item::before {
            content: '';
            position: absolute;
            left: -12px;
            top: 50%;
            width: 10px;
            height: 1px;
            background: #d0d0d0;
            transform: translateY(-50%);
        }
        
        .tree-current {
            border-left-color: transparent;
            background: transparent;
            margin-bottom: 20px;
            position: relative;
        }
        
        .tree-current .tree-section-label { display: block; }
        
        .tree-current-item {
            font-weight: 600;
            border-left: 0 !important;
            background: transparent !important;
            position: relative;
        }
        
        /* Connection lines from current item to related items */
        .tree-current-item::after { content: none; }
        
        /* Vertical spine for the tree */
        .reference-tree::before { content: none; }

        /* ASCII Toggle Button */
        .ascii-toggle-btn {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #f0f0f0;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
            transition: all 0.2s;
            min-width: 40px;
        }

        .ascii-toggle-btn[data-enabled="true"] {
            background: #4caf50;
            color: white;
            border-color: #4caf50;
        }

        .ascii-toggle-btn[data-enabled="false"] {
            background: #f44336;
            color: white;
            border-color: #f44336;
        }

        .ascii-toggle-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        
        /* Loading Screen */
        #loading-screen {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 10000;
        }
        .loading-ui { text-align: center; }
        .loading-wordmark { font-weight: 700; letter-spacing: 3px; font-size: 16px; color: #555; }
        .loading-caption { margin-top: 8px; font-family: Arial, sans-serif; font-size: 12px; color: #666; text-align: center; }
        .loading-icon {
            width: 28px;
            height: 28px;
            margin: 10px auto 0;
            position: relative;
            border-radius: 50%;
            border: 1px solid rgba(0,0,0,0.12);
            animation: orbit 1.15s cubic-bezier(.6,.04,.26,.9) infinite;
        }
        .loading-icon::before,
        .loading-icon::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            border-radius: 50%;
            background: #000;
            transform: translate(-50%, -50%);
        }
        .loading-icon::before {
            width: 6px;
            height: 6px;
            transform: translate(-50%, -50%) translateX(10px);
            box-shadow: 0 0 6px rgba(0,0,0,0.25);
        }
        .loading-icon::after {
            width: 3px;
            height: 3px;
            opacity: 0.45;
            transform: translate(-50%, -50%) translateX(-10px);
        }
        @keyframes orbit { to { transform: rotate(360deg); } }
        
        .loading-container {
            text-align: center;
            max-width: 600px;
            padding: 40px;
        }
        
        .loading-title {
            font-size: 48px;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 10px;
            letter-spacing: 4px;
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        .loading-subtitle {
            font-size: 16px;
            color: #888;
            margin-bottom: 40px;
            letter-spacing: 2px;
        }
        
        .loading-progress {
            margin-bottom: 40px;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333;
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #7bb3f0);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        
        .loading-status {
            font-size: 14px;
            color: #ccc;
            margin-bottom: 10px;
        }
        
        .loading-steps {
            text-align: left;
            max-width: 400px;
            margin: 0 auto;
        }
        
        .step {
            font-size: 14px;
            color: #666;
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .step.active {
            color: #4a90e2;
            background: rgba(74, 144, 226, 0.1);
        }
        
        .step.completed {
            color: #5cb85c;
            background: rgba(92, 184, 92, 0.1);
        }
        
        @keyframes glow {
            from {
                text-shadow: 0 0 20px rgba(74, 144, 226, 0.5);
            }
            to {
                text-shadow: 0 0 30px rgba(74, 144, 226, 0.8), 0 0 40px rgba(74, 144, 226, 0.3);
            }
        }
        
        /* Hide main content during loading */
        #main-content {
            display: none;
        }
        
        #main-content.loaded {
            display: block;
        }

        /* Tooltip styles */
        .hover-tooltip {
            position: fixed;
            background: whitesmoke;
            color: black;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 10000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: nowrap;
            max-width: 300px;
            overflow: hidden;
            text-overflow: ellipsis;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s ease-out, transform 0.2s ease-out;
        }

        .hover-tooltip.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .tooltip-content {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .tooltip-icon {
            width: 16px;
            height: 16px;
            opacity: 0.8;
        }
    </style>
</head>


<body>
    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-ui">
            <div class="loading-caption" id="loading-status">initializing…</div>
            <div class="loading-icon" aria-hidden="true"></div>
        </div>
    </div>

    <!-- Main Content (hidden during loading) -->
    <!-- Tooltip -->
    <div id="hover-tooltip" class="hover-tooltip">
        <div class="tooltip-content">
            <svg class="tooltip-icon" viewBox="0 0 24 24" fill="currentColor">
                <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>
            </svg>
            <span id="tooltip-text"></span>
        </div>
    </div>

    <div id="main-content" style="display: none;">
    
    <!-- ASCII Background Layer (always visible, non-interactive) -->
    <div class="ascii-background" id="ascii-background">
        <!-- Glassy overlays with maximum z-index -->
        <div class="glassy-overlay"></div>
        <div class="diffused-texture"></div>
    </div>

    <!-- Text Constellation (main interactive layer) -->
    <div class="text-constellation" id="text-constellation">
        <div class="text-container" id="text-container"></div>
    </div>

    <!-- Selection Panel (moved to floating right side) -->
    <div class="selection-panel" id="selection-panel">
        <h4>Selected Items</h4>
            <div class="selection-items" id="selection-items"></div>
                </div>
    
    <!-- Right Panel with VStack of containers -->
    <div class="right-panel" id="right-panel" style="display: none; top: 70px;">
        
        <!-- From Book Container -->
        <div class="panel-container" id="from-book-container" style="display: none;">
            <div class="tree-section-label">From Book</div>
            <div class="book-info">
                <!-- Book Cover -->
                <div class="book-cover-display" id="current-item-book-cover" style="text-align: center;">
                    <img id="current-item-cover-image" src="" alt="Book Cover" style="width: 60px; height: 80px; object-fit: cover; border-radius: 6px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); display: none;">
                </div>
                <!-- Book Text -->
                <div class="book-text">
                    <div class="book-title" id="current-item-book-title"></div>
                    <div class="book-author" id="current-item-book-author"></div>
                </div>
            </div>
        </div>

        <!-- Current Item Info Container with Hierarchical Tree -->
        <div class="panel-container" id="item-info-container" style="display: none;">
            <div class="item-info">
                <!-- Hierarchical Reference Tree -->
                <div class="reference-tree" id="reference-tree">
                    <!-- Tree structure will be dynamically generated -->
                </div>
        </div>
    </div>
    
        <!-- More from Same Book Container -->
        <div class="panel-container" id="same-book-container" style="display: none;">
            <div class="tree-section-label">More from same book</div>
            <div class="clickable-items" id="same-book-items">
                <div class="no-items">No other entries</div>
            </div>
        </div>

        <!-- More from Other Books Container -->
        <div class="panel-container" id="other-book-container" style="display: none;">
            <div class="tree-section-label">More from other books</div>
            <div class="clickable-items" id="other-book-items">
                <div class="no-items">No entries yet</div>
            </div>
        </div>

    </div>

    <!-- Left Panel: How it was made (hidden until selection) -->
    <!-- <div class="right-panel" id="left-panel" style="left: 10px; right: auto; display: none; top: 70px;">
        <div class="panel-container">
            <h4>Process documentation</h4>
            <div id="how-made-list" style="max-height: 50vh; overflow-y: auto; display: grid; gap: 8px;">
            </div>
        </div>
    </div> -->

    <!-- Gallery Modal -->
    <div id="gallery-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:10001; align-items:center; justify-content:center; pointer-events:auto;">
        <div style="position:relative; display:flex; align-items:center; gap:12px; pointer-events:auto;">
            <button id="gallery-prev" style="background:#fff; border:1px solid #ccc; border-radius:4px; width:36px; height:36px; cursor:pointer;">‹</button>
            <img id="gallery-image" src="" alt="Gallery" style="max-width:80vw; max-height:90vh; border-radius:8px; box-shadow:0 8px 24px rgba(0,0,0,0.4);">
            <button id="gallery-next" style="background:#fff; border:1px solid #ccc; border-radius:4px; width:36px; height:36px; cursor:pointer;">›</button>
            <button id="gallery-close" style="position:absolute; top:-10px; right:-10px; background:#fff; border:1px solid #ccc; border-radius:50%; width:28px; height:28px; cursor:pointer;">✕</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from '../three.module.js';
        import { OrbitControls } from '../jsm/OrbitControls.js';
        
        // Console logging toggle (silence logs in production/preview)
        const LOGS_ENABLED = false;
        if (!LOGS_ENABLED && typeof console !== 'undefined') {
            console.log = () => {};
        }
        
        // Loading Screen Management
        const loadingSteps = [
            { id: 'step-data', status: 'Loading data...', progress: 20 },
            { id: 'step-geometry', status: 'Creating geometry...', progress: 40 },
            { id: 'step-rendering', status: 'Initializing renderer...', progress: 60 },
            { id: 'step-controls', status: 'Setting up controls...', progress: 80 },
            { id: 'step-complete', status: 'Ready to explore', progress: 100 }
        ];
        
        let currentStep = 0;
        
        function updateLoadingProgress(stepIndex, customStatus = null) {
            const steps = ['step-data','step-geometry','step-rendering','step-controls','step-complete'];
            const statusEl = document.getElementById('loading-status');
            
            // Progress indicator (spinner only; keep ratios for potential future use)
            const ratios = [0.15, 0.35, 0.65, 0.85, 1.0];
            const ratio = ratios[Math.min(stepIndex, ratios.length - 1)];
            
            if (statusEl) {
                statusEl.textContent = customStatus || 'loading…';
            }
            
            // Also mark step states if they exist
            steps.forEach((id, idx) => {
                const el = document.getElementById(id);
                if (!el) return;
                if (idx < stepIndex) el.classList.add('completed');
                else if (idx === stepIndex) el.classList.add('active');
            });
        }
        
        function completeLoading() {
            setTimeout(() => {
                const loadingScreen = document.getElementById('loading-screen');
                const mainContent = document.getElementById('main-content');
                if (loadingScreen) loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    if (loadingScreen && loadingScreen.parentNode) loadingScreen.parentNode.removeChild(loadingScreen);
                    if (mainContent) mainContent.style.display = 'block';
                }, 300);
            }, 200);
        }
        
        // Start with first step
        updateLoadingProgress(0);
        import { ConvexGeometry } from '../jsm/ConvexGeometry.js';
        import { AsciiEffect } from '../jsm/AsciiEffect.js';

        let camera, controls, scene, renderer, effect;
        let lastAsciiRenderTime = 0; // throttle ASCII renders
        let needsAsciiRender = true; // event-driven ASCII renders
        const asciiTargetMs = 1000 / 12; // ~12 FPS target for ASCII
        const asciiIdleMs = 1000; // ensure at least one render per second when idle
        let points, raycaster, mouse, pointData;
        let asciiTextSprites = [];
        let coordinateScale = 3; // Default scale factor for coordinates (3x reduction)
        let itemSizeScale = 3.6; // Default size multiplier for selected items
        let zoomDistance = 40; // Default distance when focusing on items
        let baseReferenceDistance = null; // Will be calculated when first item is focused
        const CONNECTION_LEVELS = 2; // Number of relationship levels away from focused item to include
        const PANEL_LEVELS = Math.max(1, CONNECTION_LEVELS - 1); // Sidebar shows one level less to match geometry depth
        
        // Helper function to get current opacity values from sliders (source of truth)
        function getOpacityValues() {
            const selectedSlider = document.getElementById('selected-text-opacity');
            const unselectedSlider = document.getElementById('unselected-opacity');
            
            return {
                selected: selectedSlider ? (selectedSlider.value / 100) : 1.0,
                unselected: unselectedSlider ? (unselectedSlider.value / 100) : 0.12
            };
        }
        
        // Compute a uniform scale for selected sprites so every item has the same visual height
        function computeUniformSelectedScale(sprite) {
            const original = sprite.userData && sprite.userData.originalScale ? sprite.userData.originalScale : { x: sprite.scale.x || 1, y: sprite.scale.y || 1, z: sprite.scale.z || 1 };
            const safeOriginalY = Math.max(0.0001, original.y);
            const aspectRatio = original.x / safeOriginalY; // preserve width:height
            // Use the slider value as the absolute target height for all selected items
            const targetHeight = itemSizeScale; // uniform visual height
            const targetWidth = targetHeight * aspectRatio;
            const targetZ = original.z; // keep Z scale unchanged
            return { x: targetWidth, y: targetHeight, z: targetZ };
        }
        
        // Distance-aware hover-selected scale: scales up from current apparent size
        function computeHoverSelectedScale(sprite, camera) {
            const original = sprite.userData && sprite.userData.originalScale ? sprite.userData.originalScale : { x: sprite.scale.x || 1, y: sprite.scale.y || 1, z: sprite.scale.z || 1 };
            
            // Get the item's current scale (which may already include distance compensation)
            const currentScale = { x: sprite.scale.x, y: sprite.scale.y, z: sprite.scale.z };
            
            // Calculate what the selected scale would be for this item
            const selectedScale = computeUniformSelectedScale(sprite);
            
            // If the item is already larger than it would be when selected, don't scale it down
            // Otherwise, scale it up to the selected size
            const targetX = Math.max(currentScale.x, selectedScale.x);
            const targetY = Math.max(currentScale.y, selectedScale.y);
            const targetZ = currentScale.z; // Keep Z unchanged
            
            return { x: targetX, y: targetY, z: targetZ };
        }
        
        // Proper distance-based scaling calculation
        function calculateDistanceBasedScale(sprite, camera) {
            // Calculate actual distance from camera to sprite
            const actualDistance = camera.position.distanceTo(sprite.position);
            
            // Set base reference distance on first calculation (use zoom distance as reference)
            if (baseReferenceDistance === null) {
                baseReferenceDistance = zoomDistance;
                console.log(`📏 Setting base reference distance: ${baseReferenceDistance} units`);
            }
            
            // Calculate scale factor based on distance ratio
            // Objects farther than reference distance should appear larger to maintain visual consistency
            const distanceRatio = actualDistance / baseReferenceDistance;
            
            // Apply inverse square relationship for more realistic scaling
            // Close objects = smaller scale, far objects = larger scale
            const baseScale = Math.sqrt(distanceRatio);
            
            // Apply item size multiplier from slider
            const finalScale = baseScale * itemSizeScale;
            
            // Clamp to reasonable bounds
            const clampedScale = Math.max(0.5, Math.min(15.0, finalScale));
            
            console.log(`📐 Distance Scaling - Actual: ${actualDistance.toFixed(1)}, Reference: ${baseReferenceDistance}, Ratio: ${distanceRatio.toFixed(2)}, Base: ${baseScale.toFixed(2)}, Final: ${clampedScale.toFixed(2)}`);
            
            return clampedScale;
        }
        let selectedPoints = [];
        let currentMesh;
        let autoOrbitEnabled = true;
        let autoOrbitSpeed = 0.002;
        let currentView = 'text'; // Track current view - default to text constellation
        
        // Connection system variables
        let connectionLines = [];
        let allEmbeddingsData = [];
        let currentFocusedItem = null;
        let connectedSprites = new Set(); // Track all sprites that are currently connected (for hover logic)
        let currentConnectedItems = new Set(); // Store current connected items for camera completion callback
        
        // Distance monitoring
        let distanceMonitorInterval = null;
        
        function startDistanceMonitoring() {
            // Clear any existing interval
            if (distanceMonitorInterval) {
                clearInterval(distanceMonitorInterval);
            }
            
            distanceMonitorInterval = setInterval(() => {
                if (currentFocusedItem && textConstellation && textConstellation.camera) {
                    // Find the sprite for the current focused item
                    const sprite = textConstellation.textSprites.find(sprite => 
                        sprite.userData.text === currentFocusedItem.entry
                    );
                    
                    if (sprite) {
                        const cameraPosition = textConstellation.camera.position;
                        const spritePosition = sprite.position;
                        const distance = cameraPosition.distanceTo(spritePosition);
                        const controlsTarget = textConstellation.controls.target;
                        
                        console.log(`📏 Camera Distance Monitor:
    📍 Focused Item: "${currentFocusedItem.entry.substring(0, 30)}..."
    📷 Camera Position: (${cameraPosition.x.toFixed(2)}, ${cameraPosition.y.toFixed(2)}, ${cameraPosition.z.toFixed(2)})
    🎯 Sprite Position: (${spritePosition.x.toFixed(2)}, ${spritePosition.y.toFixed(2)}, ${spritePosition.z.toFixed(2)})
    🎮 Controls Target: (${controlsTarget.x.toFixed(2)}, ${controlsTarget.y.toFixed(2)}, ${controlsTarget.z.toFixed(2)})
    📐 Distance to Sprite: ${distance.toFixed(2)} units
    📊 Controls Distance: ${cameraPosition.distanceTo(controlsTarget).toFixed(2)} units`);
                    } else {
                        console.log(`📏 Distance Monitor: No sprite found for focused item "${currentFocusedItem.entry.substring(0, 30)}..."`);
                    }
                } else {
                    console.log('📏 Distance Monitor: No focused item or camera available');
                }
            }, 1000); // Every second
            
            console.log('📏 Started distance monitoring (every 1 second)');
        }
        
        function stopDistanceMonitoring() {
            if (distanceMonitorInterval) {
                clearInterval(distanceMonitorInterval);
                distanceMonitorInterval = null;
                console.log('📏 Stopped distance monitoring');
            }
        }
        
        // Make monitoring functions available globally for debugging
        window.startDistanceMonitoring = startDistanceMonitoring;
        window.stopDistanceMonitoring = stopDistanceMonitoring;
        
        // Connection types and colors
        const CONNECTION_TYPES = {
            PARENT: { color: 0x1a0dab, name: 'parent' },
            SEE: { color: 0x7a6a3e, name: 'see' },
            SEE_ALSO: { color: 0x6c2f33, name: 'see_also' },
            CHILDREN: { color: 0x1a0dab, name: 'children' }
        };

        // Focus on item without making it selected (camera movement only)
        window.focusOnItemById = function(id, text) {
            const startTime = performance.now();
            console.log('🎯 focusOnItemById called:', { id, text });
            
            const findStartTime = performance.now();
            const foundItem = findItemById(id, text);
            const findEndTime = performance.now();
            console.log(`⏱️ findItemById took: ${(findEndTime - findStartTime).toFixed(2)}ms`);
            console.log('📝 Found item:', foundItem ? foundItem.entry : 'NOT FOUND');
            
            if (foundItem && textConstellation && textConstellation.textSprites) {
                // Find the corresponding sprite
                const spriteSearchStart = performance.now();
                const sprite = textConstellation.textSprites.find(sprite => 
                    sprite.userData.text === (foundItem.text || foundItem.entry)
                );
                const spriteSearchEnd = performance.now();
                console.log(`⏱️ sprite search took: ${(spriteSearchEnd - spriteSearchStart).toFixed(2)}ms`);
                console.log('🎭 Found sprite:', sprite ? 'YES' : 'NO');
                
                if (sprite) {
                    // Only move camera to focus on the item, don't select it
                    const cameraStart = performance.now();
                    console.log('📹 Centering camera on sprite');
                    textConstellation.centerCameraOnSprite(sprite);
                    const cameraEnd = performance.now();
                    console.log(`⏱️ camera centering took: ${(cameraEnd - cameraStart).toFixed(2)}ms`);
                    
                    const totalTime = performance.now() - startTime;
                    console.log(`⏱️ TOTAL focusOnItemById took: ${totalTime.toFixed(2)}ms`);
                    return true;
                } else {
                    console.log('❌ No sprite found for item:', foundItem.entry);
                }
            } else {
                console.log('❌ Missing requirements:', {
                    foundItem: !!foundItem,
                    textConstellation: !!textConstellation,
                    textSprites: !!(textConstellation && textConstellation.textSprites)
                });
            }
            return false;
        };
        
        // Make item the current selection (full selection with connections)
        window.selectItemAsCurrentById = function(id, text) {
            const startTime = performance.now();
            console.log('🔍 selectItemAsCurrentById called:', { id, text });
            
            const findStartTime = performance.now();
            const foundItem = findItemById(id, text);
            const findEndTime = performance.now();
            console.log(`⏱️ findItemById took: ${(findEndTime - findStartTime).toFixed(2)}ms`);
            console.log('📝 Found item:', foundItem ? foundItem.entry : 'NOT FOUND');
            
            if (foundItem && textConstellation && textConstellation.textSprites) {
                // Find the corresponding sprite
                const spriteSearchStart = performance.now();
                const sprite = textConstellation.textSprites.find(sprite => 
                    sprite.userData.text === (foundItem.text || foundItem.entry)
                );
                const spriteSearchEnd = performance.now();
                console.log(`⏱️ sprite search took: ${(spriteSearchEnd - spriteSearchStart).toFixed(2)}ms`);
                console.log('🎭 Found sprite:', sprite ? 'YES' : 'NO');
                
                if (sprite) {
                    console.log('✅ Performing full selection');
                    
                    // 1. Camera centering
                    const cameraStart = performance.now();
                    textConstellation.centerCameraOnSprite(sprite);
                    const cameraEnd = performance.now();
                    console.log(`⏱️ camera centering took: ${(cameraEnd - cameraStart).toFixed(2)}ms`);
                    
                    // 2. Sprite selection - REMOVED: Now using connection-based highlighting instead of random selection
                    console.log(`⏱️ sprite selection: SKIPPED (using connection-based highlighting)`);
                    
                    // 3. Collect all connected items first (including nested)
                    const collectStart = performance.now();
                    const allConnectedItems = collectConnectedItemsRecursively(foundItem, 0, CONNECTION_LEVELS, new Set(), new Set());
                    const collectEnd = performance.now();
                    console.log(`⏱️ collecting connected items took: ${(collectEnd - collectStart).toFixed(2)}ms`);
                    console.log(`📊 Collected ${allConnectedItems.size} total connected items (including nested)`);
                    
                    // 4. Right panel update (now with complete connected items list)
                    const panelStart = performance.now();
                    updateRightPanel(foundItem, allConnectedItems);
                    const panelEnd = performance.now();
                    console.log(`⏱️ right panel update took: ${(panelEnd - panelStart).toFixed(2)}ms`);
                    
                    // 5. Connection drawing
                    const connectionStart = performance.now();
                    updateConnectionsForItem(foundItem);
                    const connectionEnd = performance.now();
                    console.log(`⏱️ connection drawing took: ${(connectionEnd - connectionStart).toFixed(2)}ms`);
                    
                    const totalTime = performance.now() - startTime;
                    console.log(`⏱️ TOTAL selectItemAsCurrentById took: ${totalTime.toFixed(2)}ms`);

                    // Reveal UI on first selection
                    revealUIAfterSelection();

                    return true;
                } else {
                    console.log('❌ No sprite found for item:', foundItem.entry);
                }
            } else {
                console.log('❌ Missing requirements:', {
                    foundItem: !!foundItem,
                    textConstellation: !!textConstellation,
                    textSprites: !!(textConstellation && textConstellation.textSprites)
                });
            }
            return false;
        };
        
        // Book cover data
        const BOOK_COVERS = {
            'Updating to Remain the Same: Habitual New Media': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM0NC9vcmlnaW5hbF82YjZlZjY2ODQwYWZmNWY4NTMyNWY2MGNkMDM5ZmExYi5qcGciLCJlZGl0cyI6eyJyZXNpemUiOnsid2lkdGgiOjYwMCwiaGVpZ2h0Ijo2MDAsImZpdCI6Imluc2lkZSIsIndpdGhvdXRFbmxhcmdlbWVudCI6dHJ1ZX0sIndlYnAiOnsicXVhbGl0eSI6NzV9LCJmbGF0dGVuIjp7ImJhY2tncm91bmQiOnsiciI6MjAzLCJnIjoyMDMsImIiOjIwM319LCJqcGVnIjp7InF1YWxpdHkiOjc1fSwicm90YXRlIjpudWxsfX0=',
            'Code and Clay, Data and Dirt: Five Thousand Years of Urban Media': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM0Ny9vcmlnaW5hbF9lNzE0YzI3NmRkNDMxMDNhMjAyNDA2MjUtMi1nNGw4MDgucG5nIiwiZWRpdHMiOnsicmVzaXplIjp7IndpZHRoIjo2MDAsImhlaWdodCI6NjAwLCJmaXQiOiJpbnNpZGUiLCJ3aXRob3V0RW5sYXJnZW1lbnQiOnRydWV9LCJ3ZWJwIjp7InF1YWxpdHkiOjc1fSwiZmxhdHRlbiI6eyJiYWNrZ3JvdW5kIjp7InIiOjIwMywiZyI6MjAzLCJiIjoyMDN9fSwianBlZyI6eyJxdWFsaXR5Ijo3NX0sInJvdGF0ZSI6bnVsbH19',
            'The Moment of Complexity: Emerging Network Culture': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM1MC9vcmlnaW5hbF85M2NkMjY3OWQxOTQ0ZTUwMjAyNDA2MjUtMi13eW8wY2kucG5nIiwiZWRpdHMiOnsicmVzaXplIjp7IndpZHRoIjo2MDAsImhlaWdodCI6NjAwLCJmaXQiOiJpbnNpZGUiLCJ3aXRob3V0RW5sYXJnZW1lbnQiOnRydWV9LCJ3ZWJwIjp7InF1YWxpdHkiOjc1fSwiZmxhdHRlbiI6eyJiYWNrZ3JvdW5kIjp7InIiOjIwMywiZyI6MjAzLCJiIjoyMDN9fSwianBlZyI6eyJxdWFsaXR5Ijo3NX0sInJvdGF0ZSI6bnVsbH19'
        };
        const info = document.createElement('div');
        info.id = 'info';
        document.body.appendChild(info);
        const start = Date.now();

        const bookColors = {
            "Updating to Remain the Same: Habitual New Media": "#059669",
            "Code and Clay, Data and Dirt: Five Thousand Years of Urban Media": "#e53e3e",
            "The Moment of Complexity: Emerging Network Culture": "#2563eb"
        };
        
        const bookColorDescriptions = {
            "Updating to Remain the Same: Habitual New Media": "green",
            "Code and Clay, Data and Dirt: Five Thousand Years of Urban Media": "red", 
            "The Moment of Complexity: Emerging Network Culture": "blue"
        };

        const bookTitlesWithAuthors = {
            "Updating to Remain the Same: Habitual New Media": "Wendy Hui Kyong Chun",
            "Code and Clay, Data and Dirt: Five Thousand Years of Urban Media": "Shannon Mattern",
            "The Moment of Complexity: Emerging Network Culture": "Mark C. Taylor"
        };

        // Helper function to extract clean concept text without locators
        function extractCleanConcept(entryText) {
            if (!entryText) return 'Unknown';
            
            // Remove locators that typically appear at the end after commas
            // Pattern: text, page numbers, page numbers, etc.
            const cleanText = entryText.replace(/,\s*\d+[-\d]*[n]?\.?\s*\d*[-\d]*[n]?\.?\s*[a-zA-Z]*/g, '');
            
            // Also remove any remaining page references at the end
            const finalClean = cleanText.replace(/,\s*\d+[-\d]*[n]?\.?\s*$/g, '');
            
            return finalClean.trim() || 'Unknown';
        }



        async function loadEmbeddings() {
            const response = await fetch('../data/combinedv3.json');
            const data = await response.json();
            return data.map(entry => ({
                text: entry.text,
                entry: entry.entry,
                x: entry.embedding[0] / coordinateScale, // Use dynamic coordinate scale
                y: entry.embedding[1] / coordinateScale, // Use dynamic coordinate scale  
                z: entry.embedding[2] / coordinateScale, // Use dynamic coordinate scale
                citation: entry.citation,
                see: entry.see || [],
                see_also: entry.see_also || [],
                parent_text: entry.parent_text || null,
                type: entry.type,
                id: entry.id,
                spaced_subentry: entry["spaced-subentry"],
                children: entry.children || [] // Add children field for enhanced grouping
            }));
        }

        function createTextSpritesForASCII(embeddings) {
            // Clear existing ASCII sprites
            if (asciiTextSprites) {
                asciiTextSprites.forEach(sprite => {
                    scene.remove(sprite);
                    if (sprite.material.map) {
                        sprite.material.map.dispose();
                    }
                    sprite.material.dispose();
                });
            }
            
            asciiTextSprites = [];
            
            // Display all entries (no limit) to show the complete dataset
            console.log(`Creating ASCII sprites for all ${embeddings.length} entries`);
            const limitedEmbeddings = embeddings;
            pointData = limitedEmbeddings;

            // Create text sprites similar to text constellation but for ASCII scene
            limitedEmbeddings.forEach((embedding, index) => {
                const position = new THREE.Vector3(embedding.x, embedding.y, embedding.z);
                // Extract clean concept text without locators for sprite display
                const displayText = extractCleanConcept(embedding.text || embedding.entry);
                const sprite = createTextSpriteForASCII(displayText, getBookColor(embedding.citation.title), position);
                // Start unselected ASCII sprites translucent
                if (sprite && sprite.material && typeof window !== 'undefined') {
                    const initialOpacity = (typeof window.unselectedAsciiOpacity === 'number') ? window.unselectedAsciiOpacity : 0.12;
                    sprite.material.opacity = initialOpacity;
                    if (sprite.material.needsUpdate !== undefined) sprite.material.needsUpdate = true;
                }
                asciiTextSprites.push(sprite);
                scene.add(sprite);
            });
            
            selectRandomPoints(limitedEmbeddings);
            
            // Ensure all ASCII opacities reflect current defaults on load
            if (typeof updateAllAsciiOpacities === 'function') {
                updateAllAsciiOpacities();
            }
        }
        
        function drawRoundedRectFunction(context, x, y, width, height, radius, fill = false, stroke = false) {
            // Use native roundRect if available (better antialiasing), fallback to manual implementation
            if (context.roundRect) {
                context.beginPath();
                context.roundRect(x, y, width, height, radius);
                if (fill) context.fill();
                if (stroke) context.stroke();
            } else {
                // Manual implementation with better curve smoothness
                context.beginPath();
                context.moveTo(x + radius, y);
                context.lineTo(x + width - radius, y);
                context.arcTo(x + width, y, x + width, y + radius, radius);
                context.lineTo(x + width, y + height - radius);
                context.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                context.lineTo(x + radius, y + height);
                context.arcTo(x, y + height, x, y + height - radius, radius);
                context.lineTo(x, y + radius);
                context.arcTo(x, y, x + radius, y, radius);
                context.closePath();
                
                if (fill) {
                    context.fill();
                }
                if (stroke) {
                    context.stroke();
                }
            }
        }
        
        function createTextSpriteForASCII(text, color, position) {
            // Create simplified text sprite for ASCII rendering
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Much smaller canvas to match text size better
            canvas.width = 128;
            canvas.height = 32;
            
            // Simple background with rounded corners
            context.fillStyle = '#ffffff';
            drawRoundedRectFunction(context, 0, 0, canvas.width, canvas.height, 6, true, false);
            
            // Text - match tree item styling
            context.fillStyle = '#333'; // Use tree item text color
            context.font = '500 12px Arial, Helvetica, sans-serif'; // Match tree item font weight
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text.substring(0, 15), canvas.width/2, canvas.height/2); // Shorter text
            
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: (typeof window !== 'undefined' && typeof window.unselectedAsciiOpacity === 'number') ? window.unselectedAsciiOpacity : 0.12
            });
            
            const sprite = new THREE.Sprite(material);
            sprite.position.copy(position);
            sprite.scale.set(2, 1, 1); // Much smaller scale to match text size
            
            return sprite;
        }
        
        function getBookColor(title) {
            if (title.includes("Updating to Remain the Same")) return "#6C2F33"; // Self-Portrait
            if (title.includes("Code and Clay")) return "#3F4C6B"; // Formentera-like blue
            if (title.includes("The Moment of Complexity")) return "#7A6A3E"; // Masterpiece Theatre
            return "#6C2F33";
        }

        function selectRandomPoints(embeddings, specificPoint = null) {
            const selectedIndices = [];
            if (specificPoint !== null) {
                const specificIndex = embeddings.findIndex(point =>
                    point.x === specificPoint.x &&
                    point.y === specificPoint.y &&
                    point.z === specificPoint.z);
                selectedIndices.push(specificIndex);
            }
            while (selectedIndices.length < 4) {
                const randomIndex = Math.floor(Math.random() * embeddings.length);
                if (!selectedIndices.includes(randomIndex)) {
                    selectedIndices.push(randomIndex);
                }
            }

            selectedPoints = selectedIndices.map(index => embeddings[index]);
            highlightSelectedPoints(selectedIndices);
            drawMeshBetweenSelectedPoints();
        }

        function highlightSelectedPoints(selectedIndices) {
            // Safety check for ASCII sprites
            if (asciiTextSprites && Array.isArray(asciiTextSprites) && asciiTextSprites.length > 0) {
                // Update all ASCII text sprites with proper selection scaling
                asciiTextSprites.forEach((sprite, index) => {
                    if (!sprite || !sprite.scale) return; // Safety check
                    
                    if (selectedIndices.includes(index)) {
                        // Slightly larger scale for selection
                        sprite.scale.set(2.5, 1.25, 1);
                    } else {
                        // Normal scale for unselected
                        sprite.scale.set(2, 1, 1);
                    }
                });
            }
            
            // Use the centralized opacity update system
            if (typeof updateAllAsciiOpacities === 'function') {
            updateAllAsciiOpacities();
            }
        }

        function drawMeshBetweenSelectedPoints() {
            if (currentMesh) {
                scene.remove(currentMesh);
                if (currentMesh.geometry) currentMesh.geometry.dispose();
                if (currentMesh.material) currentMesh.material.dispose();
            }
            clearTextEntries();
            
            if (selectedPoints.length >= 4) {
                // Filled geometry for ASCII layer (different from text constellation wireframe)
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x8b00ff, // Purple to match text constellation
                    wireframe: false, // Filled instead of wireframe
                    transparent: true,
                    opacity: 0.3, // Lower opacity for filled geometry
                    depthTest: false,
                    depthWrite: false
                });
                const vertices = selectedPoints.map(point => new THREE.Vector3(point.x, point.y, point.z));
                const geometry = new ConvexGeometry(vertices);
                const mesh = new THREE.Mesh(geometry, material);
                mesh.renderOrder = 998; // Behind text constellation wireframe
                scene.add(mesh);
                currentMesh = mesh;
            }
        }

        function clearTextEntries() {
            const entries = document.querySelectorAll('.entry');
            entries.forEach(entry => entry.remove());
        }

        // ============= CONNECTION SYSTEM =============
        
        function clearAllConnections() {
            // Remove all existing connection lines from scene
            connectionLines.forEach(line => {
                // Try to remove from TextConstellation scene first, then main scene
                if (textConstellation?.scene) {
                    textConstellation.scene.remove(line);
                }
                if (scene) {
                    scene.remove(line);
                }
                if (line.geometry) line.geometry.dispose();
                if (line.material) line.material.dispose();
            });
            const clearedCount = connectionLines.length;
            connectionLines = [];
            console.log(`🧹 Cleared ${clearedCount} connection lines from scenes`);
        }
        
        // Cache for frequently accessed items
        const findItemCache = new Map();
        
        function findItemById(targetId, targetText) {
            // Use cache key for performance
            const cacheKey = `${targetId || ''}_${targetText || ''}`;
            if (findItemCache.has(cacheKey)) {
                return findItemCache.get(cacheKey);
            }
            
            let found = null;
            
            // Strategy 1: Exact ID match
            if (targetId) {
                found = allEmbeddingsData.find(item => item.id === targetId);
                if (found) {
                    findItemCache.set(cacheKey, found);
                    return found;
                }
            }
            
            // Strategy 2: Exact text match
            if (targetText) {
                found = allEmbeddingsData.find(item => item.entry === targetText);
                if (found) {
                    findItemCache.set(cacheKey, found);
                    return found;
                }
            }
            
            // Strategy 3: Partial text match (more expensive, so last)
            if (targetText) {
                found = allEmbeddingsData.find(item => 
                    item.entry.toLowerCase().includes(targetText.toLowerCase()) ||
                    targetText.toLowerCase().includes(item.entry.toLowerCase())
                );
                if (found) {
                    findItemCache.set(cacheKey, found);
                    return found;
                }
            }
            
            // Cache null results too to avoid repeated searches
            findItemCache.set(cacheKey, null);
            return null;
        }
        
        function createConnectionLine(fromItem, toItem, connectionType, opacity = 1.0) {
            const startPoint = new THREE.Vector3(fromItem.x, fromItem.y, fromItem.z);
            const endPoint = new THREE.Vector3(toItem.x, toItem.y, toItem.z);
            
            // Calculate distance and direction for cylinder
            const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
            const distance = direction.length();
            
            // Create thick line using CylinderGeometry (actually thick, not linewidth which doesn't work)
            const radius = 0.04; // Visible thickness
            const geometry = new THREE.CylinderGeometry(radius, radius, distance, 8, 1);
            
            const material = new THREE.MeshBasicMaterial({
                color: connectionType.color,
                opacity: Math.max(0.4, opacity),
                transparent: true,
                depthTest: true,  // Enable depth testing so lines are occluded by text items
                depthWrite: false // Don't write to depth buffer to avoid blocking other lines
            });
            
            const line = new THREE.Mesh(geometry, material);
            
            // Position the cylinder at the midpoint between start and end
            const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
            line.position.copy(midPoint);
            
            // Rotate cylinder to align with connection direction
            line.lookAt(endPoint);
            line.rotateX(Math.PI / 2); // Cylinder is along Y-axis, rotate to align with line direction
            line.userData = {
                type: connectionType.name,
                level: Math.round((1.0 - opacity) / 0.33)
            };
            
            // Render behind text sprites so they occlude the lines
            line.renderOrder = -100;
            
            console.log(`🔗 Created THICK connection line: ${connectionType.name}, radius: ${radius}, distance: ${distance.toFixed(2)}`);
            
            return line;
        }
        
        // Collect all connected items recursively (without drawing connections)
        function collectConnectedItemsRecursively(item, level = 0, maxLevel = CONNECTION_LEVELS, processedIds = new Set(), connectedItems = new Set()) {
            if (level >= maxLevel || !item || processedIds.has(item.id)) {
                return connectedItems;
            }
            
            processedIds.add(item.id);
            connectedItems.add(item); // Track all connected items
            
            // Parent connections
            if (item.parent_text) {
                const parentItem = findItemById(item.parent_text.id, item.parent_text.text);
                if (parentItem) {
                    collectConnectedItemsRecursively(parentItem, level + 1, maxLevel, processedIds, connectedItems);
                }
            }
            
            // Children connections (NEW: enhanced grouping support)
            if (item.children && Array.isArray(item.children)) {
                console.log(`🔗 Processing ${item.children.length} children for "${item.text}"`);
                item.children.forEach(childRef => {
                    const childItem = findItemById(childRef.id, childRef.text);
                    if (childItem) {
                        console.log(`   ✅ Found child: "${childItem.text}" (ID: ${childItem.id})`);
                        collectConnectedItemsRecursively(childItem, level + 1, maxLevel, processedIds, connectedItems);
                    } else {
                        console.log(`   ❌ Child not found: "${childRef.text}" (ID: ${childRef.id})`);
                    }
                });
            }
            
            // See connections
            if (item.see && Array.isArray(item.see)) {
                item.see.forEach(seeRef => {
                    const seeItem = findItemById(seeRef.id, seeRef.text);
                    if (seeItem) {
                        collectConnectedItemsRecursively(seeItem, level + 1, maxLevel, processedIds, connectedItems);
                    }
                });
            }
            
            // See also connections
            if (item.see_also && Array.isArray(item.see_also)) {
                item.see_also.forEach(seeAlsoRef => {
                    const seeAlsoItem = findItemById(seeAlsoRef.id, seeAlsoRef.text);
                    if (seeAlsoItem) {
                        collectConnectedItemsRecursively(seeAlsoItem, level + 1, maxLevel, processedIds, connectedItems);
                    }
                });
            }
            
            return connectedItems;
        }

        function drawConnectionsRecursively(item, level = 0, maxLevel = CONNECTION_LEVELS, processedIds = new Set(), connectedItems = new Set()) {
            if (level >= maxLevel || !item || processedIds.has(item.id)) {
                return;
            }
            
            processedIds.add(item.id);
            connectedItems.add(item); // Track all connected items for highlighting
            const opacity = Math.max(0.1, 1.0 - (level * 0.33)); // Decrease opacity with each level
            
            // Parent connections (blue)
            if (item.parent_text) {
                const parentItem = findItemById(item.parent_text.id, item.parent_text.text);
                if (parentItem) {
                    if (level + 1 < maxLevel) {
                        const line = createConnectionLine(item, parentItem, CONNECTION_TYPES.PARENT, opacity);
                        // Add to TextConstellation scene if available, otherwise main scene
                        const targetScene = textConstellation?.scene || scene;
                        targetScene.add(line);
                        connectionLines.push(line);
                    }
                    
                    // Recursively draw parent's connections
                    drawConnectionsRecursively(parentItem, level + 1, maxLevel, processedIds, connectedItems);
                }
            }
            
            // Children connections (purple - NEW: enhanced grouping support)
            if (item.children && Array.isArray(item.children)) {
                item.children.forEach(childRef => {
                    const childItem = findItemById(childRef.id, childRef.text);
                    if (childItem) {
                        if (level + 1 < maxLevel) {
                            const line = createConnectionLine(item, childItem, CONNECTION_TYPES.CHILDREN, opacity);
                            // Add to TextConstellation scene if available, otherwise main scene
                            const targetScene = textConstellation?.scene || scene;
                            targetScene.add(line);
                            connectionLines.push(line);
                        }
                        
                        // Recursively draw child's connections
                        drawConnectionsRecursively(childItem, level + 1, maxLevel, processedIds, connectedItems);
                    }
                });
            }
            
            // See connections (green)
            if (item.see && Array.isArray(item.see)) {
                item.see.forEach(seeRef => {
                    const seeItem = findItemById(seeRef.id, seeRef.text);
                    if (seeItem) {
                        if (level + 1 < maxLevel) {
                            const line = createConnectionLine(item, seeItem, CONNECTION_TYPES.SEE, opacity);
                            const targetScene = textConstellation?.scene || scene;
                            targetScene.add(line);
                            connectionLines.push(line);
                        }
                        
                        // Recursively draw see item's connections
                        drawConnectionsRecursively(seeItem, level + 1, maxLevel, processedIds, connectedItems);
                    }
                });
            }
            
            // See also connections (orange)
            if (item.see_also && Array.isArray(item.see_also)) {
                item.see_also.forEach(seeAlsoRef => {
                    const seeAlsoItem = findItemById(seeAlsoRef.id, seeAlsoRef.text);
                    if (seeAlsoItem) {
                        if (level + 1 < maxLevel) {
                            const line = createConnectionLine(item, seeAlsoItem, CONNECTION_TYPES.SEE_ALSO, opacity);
                            const targetScene = textConstellation?.scene || scene;
                            targetScene.add(line);
                            connectionLines.push(line);
                        }
                        
                        // Recursively draw see also item's connections
                        drawConnectionsRecursively(seeAlsoItem, level + 1, maxLevel, processedIds, connectedItems);
                    }
                });
            }
        }
        
        function highlightConnectedItems(connectedItems, applyScaling = false) {
            if (!textConstellation || !textConstellation.textSprites) {
                return;
            }
            
            // Get current opacity values from sliders (source of truth)
            const opacityValues = getOpacityValues();
            const selectedOpacity = opacityValues.selected;
            const unselectedOpacity = opacityValues.unselected;
            
            // Create a simple lookup set for connected items (much faster)
            const connectedLookup = new Set();
            connectedItems.forEach(item => {
                connectedLookup.add(item.text || item.entry);
            });
            
            console.log(`🔍 highlightConnectedItems: ${connectedItems.length} items to highlight (scaling: ${applyScaling}):`, 
                Array.isArray(connectedItems) ? connectedItems.map(item => (item.text || item.entry).substring(0, 30) + '...') : connectedItems);
            
            // SINGLE pass through all sprites - do everything at once
            const selectedSprites = [];
            const sprites = textConstellation.textSprites;
            const originalColors = textConstellation.originalColors;
            
            // Clear previous connected sprites tracking
            connectedSprites.clear();
            
            // Super fast sprite processing - minimal operations
            for (let i = 0; i < sprites.length; i++) {
                const sprite = sprites[i];
                const isConnected = connectedLookup.has(sprite.userData.text);
                
                if (isConnected) {
                    // Selected styling with smart scaling
                    sprite.material.opacity = selectedOpacity;
                    sprite.material.depthTest = false;
                    sprite.renderOrder = 1000;
                    sprite.position.z = sprite.userData.originalPosition.z + 0.1; // Bring forward slightly
                    
                    // Purple stroke for current selection (focused item only)
                    const isCurrent = currentFocusedItem && sprite.userData.text === (currentFocusedItem.text || currentFocusedItem.entry);
                    if (isCurrent) {
                        applyPurpleStroke(sprite);
                    } else {
                        removePurpleStroke(sprite);
                    }
                    
                    // Track connected
                    connectedSprites.add(sprite);
                    selectedSprites.push(sprite);
                    
                    // Apply uniform selection scaling ONLY if applyScaling is true (after camera focus)
                    if (applyScaling && textConstellation && textConstellation.camera && sprite.position) {
                        const targetScale = computeUniformSelectedScale(sprite);
                        sprite.scale.set(targetScale.x, targetScale.y, targetScale.z);
                        sprite.userData.currentDistance = textConstellation.camera.position.distanceTo(sprite.position);
                        sprite.userData.currentScale = targetScale.y;
                    }
                } else {
                    // Unselected styling - use slider value for opacity (source of truth)
                    const opacityValues = getOpacityValues();
                    sprite.material.opacity = opacityValues.unselected;
                    sprite.material.depthTest = true;
                    sprite.position.z = sprite.userData.originalPosition.z;
                    sprite.renderOrder = 0;
                    // Remove stroke and restore original size
                    removePurpleStroke(sprite);
                    if (sprite.userData.originalScale) {
                        const s = sprite.userData.originalScale;
                        sprite.scale.set(s.x, s.y, s.z);
                    } else {
                        sprite.scale.set(1, 1, 1);
                    }
                }
            }
            
            // Update selected sprites array
            textConstellation.selectedSprites = selectedSprites;
            
            console.log(`✅ highlightConnectedItems: Found ${selectedSprites.length} sprites out of ${connectedItems.length} expected items`);
        }
        
        function updateConnectionsForItem(focusedItem) {
            const startTime = performance.now();
            console.log('🔗 updateConnectionsForItem started');
            
            // Clear existing connections
            const clearStart = performance.now();
            clearAllConnections();
            const clearEnd = performance.now();
            console.log(`⏱️ clearAllConnections took: ${(clearEnd - clearStart).toFixed(2)}ms`);
            
            // Quick mesh cleanup
            const meshStart = performance.now();
            if (textConstellation?.currentMesh) {
                textConstellation.scene.remove(textConstellation.currentMesh);
                textConstellation.currentMesh.geometry?.dispose();
                textConstellation.currentMesh.material?.dispose();
                textConstellation.currentMesh = null;
            }
            
            if (typeof currentMesh !== 'undefined' && currentMesh) {
                scene.remove(currentMesh);
                currentMesh.geometry?.dispose();
                currentMesh.material?.dispose();
                currentMesh = null;
            }
            const meshEnd = performance.now();
            console.log(`⏱️ mesh cleanup took: ${(meshEnd - meshStart).toFixed(2)}ms`);
            
            if (!focusedItem) return;
            
            // Draw connections and collect connected items
            const recursiveStart = performance.now();
            const connectedItems = new Set();
            drawConnectionsRecursively(focusedItem, 0, CONNECTION_LEVELS, new Set(), connectedItems);
            const recursiveEnd = performance.now();
            console.log(`⏱️ drawConnectionsRecursively took: ${(recursiveEnd - recursiveStart).toFixed(2)}ms`);
            console.log(`📊 Created ${connectionLines.length} connection lines for ${connectedItems.size} items`);
            
            // Store connected items globally for camera completion callback
            currentConnectedItems = connectedItems;
            
            // Highlight connected items 
            const highlightStart = performance.now();
            highlightConnectedItems(connectedItems, false); 
            const highlightEnd = performance.now();
            console.log(`⏱️ highlightConnectedItems took: ${(highlightEnd - highlightStart).toFixed(2)}ms (no scaling applied yet)`);
            
            const totalTime = performance.now() - startTime;
            console.log(`⏱️ TOTAL updateConnectionsForItem took: ${totalTime.toFixed(2)}ms`);
        }

        function renderHeader() {
            const headerContainer = document.createElement('div');
            headerContainer.className = 'header';

            const topLeftHeader = document.createElement('div');
            topLeftHeader.className = 'top-left';
            topLeftHeader.style.display = 'none';
            topLeftHeader.id = 'top-left-title';
            topLeftHeader.innerHTML = '<div style="font-weight: bold;">Index.Training</div><div class="subheader" style="font-size: 13px; color: #444;">mapping index data</div>';
            document.body.appendChild(topLeftHeader);

            const centerHeader = document.createElement('div');
            centerHeader.className = 'centerheader';
            centerHeader.id = 'center-prompt';
            centerHeader.innerHTML = '<div>Click anywhere to explore</div>';
            centerHeader.style.display = 'none'; 
            document.body.appendChild(centerHeader);

            const topRightHeader = document.createElement('div');
            topRightHeader.className = 'top-right';
            topRightHeader.innerHTML = '<div class="link"><a href="/method.html" aria-label="Information about this visualization">ℹ</a></div>';
            document.body.appendChild(topRightHeader);

        }

        class TextConstellation {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.textObjects = [];
                this.textSprites = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.mouseScreenPosition = { x: 0, y: 0 };
                this.animationId = null;
                this.isControlsActive = false; // Track when orbit controls are being used
                this.embeddings = [];
                this.container = document.getElementById('text-constellation');
                this.hoveredSprite = null;
                this.autoOrbitEnabled = false;
                this.autoOrbitSpeed = 0.002;
                // Low-power animation controls
                this.lowPowerMode = true;
                this.desiredFps = 12;
                this.minFrameMs = 1000 / this.desiredFps;
                this.lastRenderTime = 0;
                this.frameCounter = 0;
                this.selectedSprites = [];
                this.currentMesh = null;
                
                // Color states for interaction feedback
                this.originalColors = new Map();
                this.hoverColor = '#1a0dab';
                this.selectedColor = '#1a0dab';
                this.geometryColor = '#1a0dab';
                
                // Canvas cache for performance
                this.canvasCache = new Map(); // Cache canvases by color+text combo
                
                // Drag detection for click cancellation
                this.isDragging = false;
                this.dragStartPosition = { x: 0, y: 0 };
                this.dragThreshold = 5; // pixels
                
                // Camera centering
                this.isCentering = false;
                
                // Performance optimizations
                this.frustum = new THREE.Frustum();
                this.cameraMatrix = new THREE.Matrix4();
                this.visibleTexts = [];
                this.textPool = [];
                this.activeTexts = [];
                
                // Child lookup optimization for enhanced grouping
                this.childLookupMap = new Map(); // Maps parent ID to array of child items
                
                // Book cover data from method.html
                this.bookCovers = {
                    'Updating to Remain the Same: Habitual New Media': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM0NC9vcmlnaW5hbF82YjZlZjY2ODQwYWZmNWY4NTMyNWY2MGNkMDM5ZmExYi5qcGciLCJlZGl0cyI6eyJyZXNpemUiOnsid2lkdGgiOjYwMCwiaGVpZ2h0Ijo2MDAsImZpdCI6Imluc2lkZSIsIndpdGhvdXRFbmxhcmdlbWVudCI6dHJ1ZX0sIndlYnAiOnsicXVhbGl0eSI6NzV9LCJmbGF0dGVuIjp7ImJhY2tncm91bmQiOnsiciI6MjAzLCJnIjoyMDMsImIiOjIwM319LCJqcGVnIjp7InF1YWxpdHkiOjc1fSwicm90YXRlIjpudWxsfX0=',
                    'Code and Clay, Data and Dirt: Five Thousand Years of Urban Media': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM0Ny9vcmlnaW5hbF9lNzE0YzI3NmRkNDMxMDNhMjAyNDA2MjUtMi1nNGw4MDgucG5nIiwiZWRpdHMiOnsicmVzaXplIjp7IndpZHRoIjo2MDAsImhlaWdodCI6NjAwLCJmaXQiOiJpbnNpZGUiLCJ3aXRob3V0RW5sYXJnZW1lbnQiOnRydWV9LCJ3ZWJwIjp7InF1YWxpdHkiOjc1fSwiZmxhdHRlbiI6eyJiYWNrZ3JvdW5kIjp7InIiOjIwMywiZyI6MjAzLCJiIjoyMDN9fSwianBlZyI6eyJxdWFsaXR5Ijo3NX0sInJvdGF0ZSI6bnVsbH19',
                    'The Moment of Complexity: Emerging Network Culture': 'https://images.are.na/eyJidWNrZXQiOiJhcmVuYV9pbWFnZXMiLCJrZXkiOiIyOTAxMDM1MC9vcmlnaW5hbF85M2NkMjY3OWQxOTQ0ZTUwMjAyNDA2MjUtMi13eW8wY2kucG5nIiwiZWRpdHMiOnsicmVzaXplIjp7IndpZHRoIjo2MDAsImhlaWdodCI6NjAwLCJmaXQiOiJpbnNpZGUiLCJ3aXRob3V0RW5sYXJnZW1lbnQiOnRydWV9LCJ3ZWJwIjp7InF1YWxpdHkiOjc1fSwiZmxhdHRlbiI6eyJiYWNrZ3JvdW5kIjp7InIiOjIwMywiZyI6MjAzLCJiIjoyMDN9fSwianBlZyI6eyJxdWFsaXR5Ijo3NX0sInJvdGF0ZSI6bnVsbH19'
                };
                
                // Bind methods
                this.animate = this.animate.bind(this);
                this.onMouseMove = this.onMouseMove.bind(this);
                this.onMouseClick = this.onMouseClick.bind(this);
                this.onWindowResize = this.onWindowResize.bind(this);
            }

            async loadEmbeddings() {
                try {
                    const response = await fetch('../data/combinedv3.json');
                    const data = await response.json();
                    this.embeddings = data.map(entry => ({
                        text: entry.text,
                        entry: entry.entry,
                        x: entry.embedding[0] / coordinateScale, // Use dynamic coordinate scale
                        y: entry.embedding[1] / coordinateScale, // Use dynamic coordinate scale
                        z: entry.embedding[2] / coordinateScale, // Use dynamic coordinate scale
                        citation: entry.citation,
                        color: this.getBookColor(entry.citation.title),
                        see: entry.see || [],
                        see_also: entry.see_also || [],
                        parent_text: entry.parent_text || null,
                        type: entry.type,
                        id: entry.id,
                        spaced_subentry: entry["spaced-subentry"],
                        children: entry.children || [] // Add children field for enhanced grouping
                    }));
                    
                    // Store globally for connection lookups
                    allEmbeddingsData = this.embeddings;
                    
                    // Build child lookup map for enhanced grouping performance
                    this.buildChildLookupMap();
                    
                    console.log(`Loaded ${this.embeddings.length} text embeddings for constellation`);
                    return this.embeddings;
                } catch (error) {
                    console.error('Error loading embeddings:', error);
                    return [];
                }
            }
            
            buildChildLookupMap() {
                // Clear existing map
                this.childLookupMap.clear();
                
                // Build map of parent ID to child items for fast lookups
                this.embeddings.forEach(entry => {
                    if (entry.children && Array.isArray(entry.children)) {
                        const childItems = entry.children.map(childRef => {
                            // Find the actual child item in embeddings
                            return this.embeddings.find(e => e.id === childRef.id);
                        }).filter(Boolean); // Remove any undefined items
                        
                        if (childItems.length > 0) {
                            this.childLookupMap.set(entry.id, childItems);
                        }
                    }
                });
                
                console.log(`Built child lookup map with ${this.childLookupMap.size} parent entries`);
            }

            getBookColor(title) {
                if (title.includes("Updating to Remain the Same")) return "#6C2F33"; // Self-Portrait
                if (title.includes("Code and Clay")) return "#3F4C6B"; // Formentera-like blue
                if (title.includes("The Moment of Complexity")) return "#7A6A3E"; // Masterpiece Theatre
                return "#6C2F33";
            }

            getTintedBackground(color) {
                // Convert hex color to RGB and create subtle tint
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                // Mix with light gray background (f5f5f5 = 245,245,245)
                const baseR = 245, baseG = 245, baseB = 245;
                const tintStrength = 0.1; // Very subtle tint
                
                const tintedR = Math.round(baseR + (r - baseR) * tintStrength);
                const tintedG = Math.round(baseG + (g - baseG) * tintStrength);
                const tintedB = Math.round(baseB + (b - baseB) * tintStrength);
                
                return `rgb(${tintedR}, ${tintedG}, ${tintedB})`;
            }

            drawRoundedRect(context, x, y, width, height, radius, fill = false, stroke = false) {
                // Use native roundRect if available (better antialiasing), fallback to manual implementation
                if (context.roundRect) {
                    context.beginPath();
                    context.roundRect(x, y, width, height, radius);
                    if (fill) context.fill();
                    if (stroke) context.stroke();
                } else {
                    // Manual implementation with better curve smoothness
                    context.beginPath();
                    context.moveTo(x + radius, y);
                    context.lineTo(x + width - radius, y);
                    context.arcTo(x + width, y, x + width, y + radius, radius);
                    context.lineTo(x + width, y + height - radius);
                    context.arcTo(x + width, y + height, x + width - radius, y + height, radius);
                    context.lineTo(x + radius, y + height);
                    context.arcTo(x, y + height, x, y + height - radius, radius);
                    context.lineTo(x, y + radius);
                    context.arcTo(x, y, x + radius, y, radius);
                    context.closePath();
                    
                    if (fill) {
                        context.fill();
                    }
                    if (stroke) {
                        context.stroke();
                    }
                }
            }

            getInvertedColors(color) {
                // For hover effect: text color becomes background, background becomes text color
                const hex = color.replace('#', '');
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                return {
                    textColor: `rgb(${r}, ${g}, ${b})`, // Original color for background
                    backgroundColor: '#ffffff' // White background becomes text color
                };
            }

            createTextSprite(text, color, position, citation = null, fullEntry = null) {
                // Create canvas for text
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                
                // Initial font setup for measurements - match tree item styling
                const fontSize = 24;
                const lineHeight = 28;
                const paddingX = 12;
                const paddingY = 8;
                const maxLineWidth = 360; // make sprites less wide
                context.font = `500 ${fontSize}px Arial, Helvetica, sans-serif`; // Match tree item font weight
                
                // Word wrap to target maxLineWidth
                const words = text.split(' ');
                let line = '';
                const lines = [];
                const lineWidths = [];
                for (let i = 0; i < words.length; i++) {
                    const testLine = line + words[i] + ' ';
                    const metrics = context.measureText(testLine);
                    if (metrics.width > maxLineWidth && i > 0) {
                        const width = context.measureText(line.trim()).width;
                        lines.push(line.trim());
                        lineWidths.push(width);
                        line = words[i] + ' ';
                    } else {
                        line = testLine;
                    }
                }
                lines.push(line.trim());
                lineWidths.push(context.measureText(lines[lines.length - 1]).width);
                
                // Compute tight canvas size
                const contentWidth = Math.ceil(Math.max(...lineWidths, 1));
                const contentHeight = lines.length * lineHeight;
                canvas.width = contentWidth + paddingX * 2;
                canvas.height = contentHeight + paddingY * 2;
                
                // Reset font after resizing canvas - match tree item styling
                context.font = `500 ${fontSize}px Arial, Helvetica, sans-serif`; // Match tree item font weight
                
                // Background
                const tintedBackground = this.getTintedBackground(color);
                const cornerRadius = 10;
                context.fillStyle = tintedBackground;
                this.drawRoundedRect(context, 0, 0, canvas.width, canvas.height, cornerRadius, true, false);
                
                // Stroke
                context.strokeStyle = color + '80';
                context.lineWidth = 2;
                this.drawRoundedRect(context, 0, 0, canvas.width, canvas.height, cornerRadius, false, true);
                
                // Text (left-aligned with padding) - match tree item styling
                context.fillStyle = '#333'; // Use tree item text color instead of sprite color
                context.textAlign = 'left';
                context.textBaseline = 'top';
                let y = paddingY;
                lines.forEach(l => {
                    context.fillText(l, paddingX, y);
                    y += lineHeight;
                });
                
                // Create texture and material
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1,
                    depthTest: true,
                    depthWrite: false,
                    opacity: 1.0
                });
                
                // Create sprite
                const sprite = new THREE.Sprite(material);
                sprite.position.set(position.x, position.y, position.z);
                
                // Scale sprite proportionally to texture aspect ratio, with compact height
                const aspect = canvas.width / canvas.height;
                const baseHeight = 1.0; // compact visual height; selection scaling will adjust later
                sprite.scale.set(baseHeight * aspect, baseHeight, 1);
                
                sprite.userData = {
                    text: text,
                    entry: fullEntry || text, // Store full entry for UI display
                    color: color,
                    originalPosition: position.clone(),
                    originalScale: sprite.scale.clone(),
                    citation: citation,
                    bookTitle: citation ? citation.title : 'Unknown',
                    originalTexture: texture,
                    strokeTexture: null,
                    strokeEnabled: false
                };
                
                // Store original color for this sprite
                this.originalColors.set(sprite, color);
                
                return sprite;
            }

            createTextConstellation() {
                console.log('Creating text constellation...');
                
                // Clear existing
                this.textSprites.forEach(sprite => {
                    this.scene.remove(sprite);
                    if (sprite.material.map) {
                        sprite.material.map.dispose();
                    }
                    sprite.material.dispose();
                });
                this.textSprites = [];
                
                // Display all embeddings (no limit)
                console.log(`Creating text sprites for all ${this.embeddings.length} entries`);
                this.embeddings.forEach((embedding, index) => {
                    // Show all entries - no artificial limit
                        const position = new THREE.Vector3(embedding.x, embedding.y, embedding.z);
                        // Extract clean concept text without locators for sprite display
                        const displayText = extractCleanConcept(embedding.text || embedding.entry);
                        const sprite = this.createTextSprite(displayText, embedding.color, position, embedding.citation, embedding.entry);
                        this.textSprites.push(sprite);
                        this.scene.add(sprite);
                });
                
                console.log(`Created ${this.textSprites.length} text sprites`);
                
                // Set all sprites to start with unselected opacity for a cleaner initial view
                const initialOpacityValues = (typeof getOpacityValues === 'function') ? getOpacityValues() : { selected: 1.0, unselected: 0.12 };
                this.textSprites.forEach(sprite => {
                    sprite.material.opacity = initialOpacityValues.unselected;
                });
            }

            setupScene() {
                // Scene
                this.scene = new THREE.Scene();
                // No background - let ASCII layer show through
                
                // Camera
                const width = window.innerWidth;
                const height = window.innerHeight;
                this.camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000);
                
                // Renderer with performance optimizations
                this.renderer = new THREE.WebGLRenderer({ 
                    antialias: false, // Disable for performance
                    powerPreference: "high-performance",
                    alpha: true // Enable transparency
                });
                this.renderer.setClearColor(0x000000, 0); // Transparent background
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio
                
                // Add to container
                this.container.appendChild(this.renderer.domElement);
                
                // Controls with improved touch support
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableZoom = true;
                this.controls.enablePan = true;
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // Allow close inspection of sprites while preventing camera clipping
                this.controls.minDistance = 0.5;  // Allow very close inspection (even closer than focus distance of 5)
                this.controls.maxDistance = 1000; // Allow zooming out for full overview
                
                // Better touch controls for pinch-to-zoom
                this.controls.touches = {
                    ONE: THREE.TOUCH.ROTATE,
                    TWO: THREE.TOUCH.DOLLY_PAN
                };
                this.controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };
                
                // More powerful zoom/pinch
                this.controls.zoomSpeed = 2.0; // Much faster zoom
                this.controls.panSpeed = 1.5; // Faster panning
                
                // Auto-orbit pause on interaction
                this.controls.addEventListener('start', () => {
                    this.autoOrbitEnabled = false;
                    this.isControlsActive = true; // Disable hover when controls are active
                    this.clearHover(); // Clear any existing hover
                    this.hideTooltip(); // Hide tooltip immediately
                });
                this.controls.addEventListener('end', () => {
                    this.isControlsActive = false; // Re-enable hover when controls stop
                    setTimeout(() => {
                        this.autoOrbitEnabled = true;
                    }, 2000); // Resume auto-orbit after 2 seconds of inactivity
                });
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);
                
                // Position camera
                this.camera.position.z = 40;
                this.controls.update();
                
                // Event listeners
                window.addEventListener('mousemove', this.onMouseMove, false);
                window.addEventListener('mousedown', this.onMouseDown.bind(this), false);
                window.addEventListener('mouseup', this.onMouseUp.bind(this), false);
                window.addEventListener('click', this.onMouseClick, false);
                
                // Mouse leave handlers to clear hover when mouse exits window or enters UI
                window.addEventListener('mouseleave', () => {
                    this.clearHover();
                }, false);
                
                document.addEventListener('mouseleave', () => {
                    this.clearHover();
                }, false);
                
                // Additional hover clearing for right panel
                const rightPanel = document.getElementById('right-panel');
                if (rightPanel) {
                    rightPanel.addEventListener('mouseenter', () => {
                        this.clearHover();
                    }, false);
                }
                window.addEventListener('resize', this.onWindowResize, false);
            }

            onMouseDown(event) {
                this.isDragging = false;
                this.dragStartPosition.x = event.clientX;
                this.dragStartPosition.y = event.clientY;
            }

            onMouseUp(event) {
                // Check if we dragged beyond threshold
                const deltaX = Math.abs(event.clientX - this.dragStartPosition.x);
                const deltaY = Math.abs(event.clientY - this.dragStartPosition.y);
                
                if (deltaX > this.dragThreshold || deltaY > this.dragThreshold) {
                    this.isDragging = true;
                    // Hide tooltip when dragging starts
                    this.hideTooltip();
                }
            }

            onMouseMove(event) {
                // No adjustment needed since sidebar overlays
                this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // Track screen position for tooltip
                this.mouseScreenPosition = { x: event.clientX, y: event.clientY };
                
                // Handle hover highlighting
                this.updateHover();
            }

            centerCameraOnSprite(sprite, duration = 300) {
                if (!sprite || this.isCentering) return;
                
                this.isCentering = true;
                const spritePosition = sprite.position.clone();
                
                // KEEP CAMERA IN CURRENT POSITION, only rotate to look at sprite and adjust distance
                const targetDistance = zoomDistance; // Use slider value for zoom distance
                
                // Get current camera state
                const currentCameraPos = this.camera.position.clone();
                const currentTarget = this.controls.target.clone();
                
                // Calculate direction from current camera position to sprite
                const directionToSprite = new THREE.Vector3()
                    .subVectors(spritePosition, currentCameraPos)
                    .normalize();
                
                // Calculate new camera position: move along the line to sprite at target distance
                const newCameraPosition = spritePosition.clone().sub(
                    directionToSprite.multiplyScalar(targetDistance)
                );
                
                // Target is the sprite position
                const newTarget = spritePosition.clone();
                
                // Smooth animation
                const startPosition = this.camera.position.clone();
                const startTarget = this.controls.target.clone();
                const startTime = Date.now();
                
                const animateCenter = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = this.easeInOutCubic(progress);
                    
                    // Interpolate both camera position AND controls target
                    this.camera.position.lerpVectors(startPosition, newCameraPosition, eased);
                    this.controls.target.lerpVectors(startTarget, newTarget, eased);
                    
                    // Update camera to look at the new target
                    this.camera.lookAt(this.controls.target);
                    this.controls.update();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animateCenter);
                    } else {
                        this.isCentering = false;
                        
                        // Log final overview information
                        const finalDistanceToSprite = this.camera.position.distanceTo(spritePosition);
                        console.log(`🎯 Camera focus completed. Distance to sprite: ${finalDistanceToSprite.toFixed(2)} units (target: ${targetDistance})`);
                        
                        // Apply scaling to connected items now that camera focus is complete
                        console.log(`🔄 Camera focus complete - now applying uniform scaling to connected items...`);
                        if (currentConnectedItems && currentConnectedItems.size > 0) {
                            // Convert Set to Array for highlightConnectedItems function
                            const connectedItemsArray = Array.from(currentConnectedItems);
                            highlightConnectedItems(connectedItemsArray, true); // true = apply scaling now
                            console.log(`✅ Applied uniform scaling to ${currentConnectedItems.size} connected items`);
                        } else {
                            console.log(`⚠️ No connected items to scale`);
                        }
                    }
                };
                
                console.log(`📍 Starting camera focus - rotating to look at sprite at distance ${targetDistance}`);
                console.log(`📍 Target sprite at: (${spritePosition.x.toFixed(2)}, ${spritePosition.y.toFixed(2)}, ${spritePosition.z.toFixed(2)})`);
                console.log(`📷 Target camera position: (${newCameraPosition.x.toFixed(2)}, ${newCameraPosition.y.toFixed(2)}, ${newCameraPosition.z.toFixed(2)})`);
                console.log(`🎯 Target distance: ${targetDistance} units`);
                
                animateCenter();
            }

            easeInOutCubic(t) {
                return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }
            
            makeUniformSize(sprite) {
                // Make selected sprites appear the same size regardless of distance
                const baseSize = 2.0; // Target visual size
                const referenceDistance = 100; // Distance at which baseSize is correct
                
                // Calculate distance from camera to sprite
                const distance = this.camera.position.distanceTo(sprite.position);
                
                // Scale factor to maintain uniform visual size
                const scaleFactor = (distance / referenceDistance) * baseSize;
                
                // Apply the scale
                sprite.scale.set(scaleFactor, scaleFactor, scaleFactor);
                
                // Store scale info for debugging
                sprite.userData.uniformScale = scaleFactor;
                sprite.userData.distanceFromCamera = distance;
            }
            
            updateDistanceCompensatedScaling() {
                // Apply uniform scaling to currently connected items (called from slider or manual refresh)
                if (currentConnectedItems && currentConnectedItems.size > 0) {
                    console.log(`🔄 Manual scaling update for ${currentConnectedItems.size} connected items`);
                    const connectedItemsArray = Array.from(currentConnectedItems);
                    // Reuse highlight to apply new uniform scale
                    highlightConnectedItems(connectedItemsArray, true);
                } else {
                    console.log(`⚠️ No connected items to update scaling for`);
                }
            }

            updateSelectionBar() {
                const selectionBar = document.getElementById('selection-bar');
                const selectionItems = document.getElementById('selection-items');
                const currentEntry = document.getElementById('current-entry');
                const currentEntryText = document.getElementById('current-entry-text');
                
                // Safety check - return early if selection bar doesn't exist (e.g., in process pages)
                if (!selectionBar) {
                    return;
                }
                
                // Add click prevention to selection bar itself (only add once)
                if (!selectionBar.hasAttribute('data-click-handler-added')) {
                    selectionBar.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    selectionBar.setAttribute('data-click-handler-added', 'true');
                }
                
                if (this.selectedSprites.length > 0) {
                    selectionBar.classList.add('active');
                    selectionItems.innerHTML = '';
                    
                    // No scene offset needed - sidebar overlays
                    
                    // Show current entry (first selected item) on the left
                    const firstSprite = this.selectedSprites[0];
                    if (firstSprite) {
                        currentEntry.style.display = 'block';
                        const entryText = firstSprite.userData.text;
                        const bookTitle = firstSprite.userData.bookTitle || 'Unknown';
                        const color = this.originalColors.get(firstSprite);
                        
                        // Update left card content
                        currentEntryText.innerHTML = `<strong style="color: ${color};">${entryText}</strong><br><em style="font-size: 10px; color: #999;">from ${bookTitle}</em>`;
                        
                        // Update left card book cover
                        const currentBookCover = document.getElementById('current-entry-book-cover');
                        currentBookCover.src = this.bookCovers[bookTitle] || this.bookCovers['The Moment of Complexity: Emerging Network Culture'];
                        currentBookCover.alt = bookTitle;
                    }
                    
                    // Show remaining selected sprites on the right (excluding the first one)
                    this.selectedSprites.slice(1).forEach((sprite, index) => {
                        const item = document.createElement('div');
                        item.className = 'selection-item';
                        
                        // Get the book title from sprite data
                        const text = sprite.userData.text;
                        const book = sprite.userData.bookTitle || 'Unknown';
                        const color = this.originalColors.get(sprite);
                        
                        // Create book cover container
                        const coverContainer = document.createElement('div');
                        coverContainer.className = 'selection-item-cover-container';
                        
                        // Create book cover image
                        const cover = document.createElement('img');
                        cover.className = 'selection-item-cover';
                        cover.src = this.bookCovers[book] || this.bookCovers['The Moment of Complexity: Emerging Network Culture']; // fallback
                        cover.alt = book;
                        
                        // Create overlay with index entry text
                        const overlay = document.createElement('div');
                        overlay.className = 'selection-item-overlay';
                        
                        const textElement = document.createElement('div');
                        textElement.className = 'selection-item-text';
                        textElement.style.color = color;
                        textElement.textContent = text;
                        textElement.title = `${text} (${book})`; // Full text and book on hover
                        
                        overlay.appendChild(textElement);
                        coverContainer.appendChild(cover);
                        item.appendChild(coverContainer);
                        item.appendChild(overlay);
                        
                        // Click to center on sprite
                        item.addEventListener('click', (e) => {
                            e.stopPropagation(); // Prevent event from bubbling to 3D scene
                            e.preventDefault();
                            this.centerCameraOnSprite(sprite);
                        });
                        
                        selectionItems.appendChild(item);
                    });
                } else {
                    selectionBar.classList.remove('active');
                    currentEntry.style.display = 'none';
                    
                    // No scene offset to remove - sidebar overlays
                }
            }

            updateSpriteColor(sprite, color, isSelected = false) {
                const text = sprite.userData.text;
                const cacheKey = `${text}_${color}_${isSelected}`;
                
                // Check cache first
                let canvas = this.canvasCache.get(cacheKey);
                
                if (!canvas) {
                    // Create new canvas only if not cached
                    canvas = document.createElement('canvas');
                    const context = canvas.getContext('2d');
                    
                    canvas.width = 512;
                    canvas.height = 128;
                    
                    context.font = '500 24px Arial, Helvetica, sans-serif'; // Match tree item font weight
                    
                    let backgroundColor, textColor, strokeColor;
                    
                    if (isSelected) {
                        // Selected items: original colors (no more purple stroke)
                        backgroundColor = this.getTintedBackground(color);
                        textColor = '#333'; // Use tree item text color
                        strokeColor = color; // Same color stroke
                    } else {
                        // Normal colors (includes hover - just full opacity)
                        backgroundColor = this.getTintedBackground(color);
                        textColor = '#333'; // Use tree item text color
                        strokeColor = color + '80'; // Add 50% transparency
                    }
                    
                    // Rebuild canvas to fit left-aligned text tightly
                    const paddingX = 12;
                    const paddingY = 8;
                    const lineHeight = 28;
                    const measureCtx = context;
                    const words = text.split(' ');
                    let line = '';
                    const lines = [];
                    const widths = [];
                    const maxLineWidth = 360;
                    for (let i = 0; i < words.length; i++) {
                        const testLine = line + words[i] + ' ';
                        const w = measureCtx.measureText(testLine).width;
                        if (w > maxLineWidth && i > 0) {
                            const lw = measureCtx.measureText(line.trim()).width;
                            lines.push(line.trim());
                            widths.push(lw);
                            line = words[i] + ' ';
                        } else {
                            line = testLine;
                        }
                    }
                    lines.push(line.trim());
                    widths.push(measureCtx.measureText(lines[lines.length - 1]).width);
                    const contentWidth = Math.ceil(Math.max(...widths, 1));
                    const contentHeight = lines.length * lineHeight;
                    canvas.width = contentWidth + paddingX * 2;
                    canvas.height = contentHeight + paddingY * 2;
                    context.font = '500 24px Arial, Helvetica, sans-serif'; // Match tree item font weight
                    
                    // Left-aligned background and stroke
                    context.fillStyle = backgroundColor;
                    this.drawRoundedRect(context, 0, 0, canvas.width, canvas.height, 12, true, false);
                    context.strokeStyle = strokeColor;
                    context.lineWidth = 2;
                    this.drawRoundedRect(context, 0, 0, canvas.width, canvas.height, 12, false, true);
                    
                    // Left-aligned text with padding
                    context.fillStyle = textColor;
                    context.textAlign = 'left';
                    context.textBaseline = 'top';
                    let y = paddingY;
                    lines.forEach(l => {
                        context.fillText(l, paddingX, y);
                        y += lineHeight;
                    });
                    
                    // Cache the canvas (limit cache size to prevent memory issues)
                    if (this.canvasCache.size < 1000) {
                        this.canvasCache.set(cacheKey, canvas);
                    }
                }
                
                // Update texture with cached or new canvas
                sprite.material.map.image = canvas;
                sprite.material.map.needsUpdate = true;
            }

            updateHover() {
                if (!this.raycaster || !this.camera || this.textSprites.length === 0) return;
                // Disable hover interactions while dragging or using orbit controls
                if (this.isDragging || this.isControlsActive) return;
                
                // Check if mouse is over UI containers
                const rightPanel = document.getElementById('right-panel');
                const isOverRightPanel = rightPanel && this.isMouseOverElement(rightPanel);
                
                // Check if mouse is outside the window bounds
                const isMouseOutside = this.mouse.x < -1 || this.mouse.x > 1 || 
                                     this.mouse.y < -1 || this.mouse.y > 1;
                
                // Disable hover if mouse is over UI or outside window
                if (isOverRightPanel || isMouseOutside) {
                    this.clearHover();
                    return;
                }
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.textSprites);
                
                // Apply hover to new sprite
                if (intersects.length > 0) {
                    const sprite = intersects[0].object;
                    
                    // If we're hovering a different sprite than before, clear the previous hover first
                    if (this.hoveredSprite && this.hoveredSprite !== sprite) {
                        this.clearHover();
                    }
                    
                    this.hoveredSprite = sprite;
                    
                    // Update sprite color first
                    const originalColor = this.originalColors.get(sprite);
                    this.updateSpriteColor(sprite, originalColor, false); // Normal colors for hover
                    
                    // If this is the current focused item, ensure purple stroke during hover
                    const isCurrentHover = currentFocusedItem && sprite.userData.text === (currentFocusedItem.text || currentFocusedItem.entry);
                    if (isCurrentHover) applyPurpleStroke(sprite); else removePurpleStroke(sprite);
                    
                    // Set hover properties AFTER color/stroke updates
                    sprite.material.opacity = 1.0; // Full opacity for hover
                    sprite.renderOrder = 1001; // Render above everything including selected items
                    sprite.material.depthTest = false; // Disable depth testing for hover (always on top)
                    sprite.position.z = sprite.userData.originalPosition.z + 0.2; // Move even further forward
                    
                    // Show tooltip on hover
                    this.showTooltip(sprite);
                    
                    document.body.style.cursor = 'pointer';
                } else {
                    // No sprite hovered, clear hover state
                    this.clearHover();
                }
            }

            isMouseOverElement(element) {
                // Get current mouse position in screen coordinates
                const rect = element.getBoundingClientRect();
                const mouseX = (this.mouse.x + 1) * window.innerWidth / 2;
                const mouseY = (-this.mouse.y + 1) * window.innerHeight / 2;
                
                return mouseX >= rect.left && mouseX <= rect.right &&
                       mouseY >= rect.top && mouseY <= rect.bottom;
            }

            showTooltip(sprite) {
                // Don't show tooltip while dragging
                if (this.isDragging) return;
                
                const tooltip = document.getElementById('hover-tooltip');
                const tooltipText = document.getElementById('tooltip-text');
                
                if (tooltip && tooltipText) {
                    // Get the full entry for complete information in tooltip
                    const itemText = sprite.userData.entry || sprite.userData.text || 'Unknown item';
                    
                    // Truncate text if too long
                    const maxLength = 50;
                    const displayText = itemText.length > maxLength ? 
                        itemText.substring(0, maxLength) + '...' : itemText;
                    
                    // Count connections for this item
                    const spriteText = sprite.userData.text || sprite.userData.entry;
                    const itemData = findItemById(null, spriteText);
                    let connectionCount = 0;
                    
                    if (itemData) {
                        // Count see references
                        if (itemData.see && Array.isArray(itemData.see)) {
                            connectionCount += itemData.see.length;
                        }
                        // Count see_also references
                        if (itemData.see_also && Array.isArray(itemData.see_also)) {
                            connectionCount += itemData.see_also.length;
                        }
                        // Count parent (+1 if exists)
                        if (itemData.parent_text) {
                            connectionCount += 1;
                        }
                    }
                    
                    // Get the book color for this sprite
                    const bookColor = sprite.userData.color || '#666666';
                    
                    // Create tooltip content with main text, colored circle, and connection count
                    tooltipText.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <div style="font-weight: bold;">${displayText}</div>
                            <div style="width: 8px; height: 8px; border-radius: 50%; background-color: ${bookColor}; flex-shrink: 0;"></div>
                        </div>
                        <div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">
                            ${connectionCount} connection${connectionCount !== 1 ? 's' : ''}
                        </div>
                    `;
                    
                    // Position tooltip near mouse cursor
                    const offsetX = 15;
                    const offsetY = -10;
                    tooltip.style.left = `${this.mouseScreenPosition.x + offsetX}px`;
                    tooltip.style.top = `${this.mouseScreenPosition.y + offsetY}px`;
                    
                    // Show tooltip with animation
                    tooltip.style.display = 'block';
                    // Force reflow to ensure the display change takes effect
                    tooltip.offsetHeight;
                    tooltip.classList.add('visible');
                }
            }

            hideTooltip() {
                const tooltip = document.getElementById('hover-tooltip');
                if (tooltip && tooltip.classList.contains('visible')) {
                    // Animate out
                    tooltip.classList.remove('visible');
                    // Hide completely after animation
                    setTimeout(() => {
                        if (!tooltip.classList.contains('visible')) {
                            tooltip.style.display = 'none';
                        }
                    }, 200); // Match the CSS transition duration
                }
            }

            clearHover() {
                // Reset any currently hovered sprite
                if (this.hoveredSprite) {
                    // Reset render order
                    this.hoveredSprite.renderOrder = this.selectedSprites.includes(this.hoveredSprite) ? 1000 : 0;
                    
                    // Reset opacity and depth based on current state using slider values
                    const isSelected = this.selectedSprites.includes(this.hoveredSprite);
                    const isConnected = connectedSprites.has(this.hoveredSprite);
                    const isSelectedOrConnected = isSelected || isConnected;
                    const hasOtherSelections = this.selectedSprites.length > 0 || connectedSprites.size > 0;
                    
                    // Get current opacity values from sliders (source of truth)
                    const opacityValues = getOpacityValues();
                    const selectedOpacity = opacityValues.selected;
                    const unselectedOpacity = opacityValues.unselected;
                    
                    if (isSelectedOrConnected) {
                        this.hoveredSprite.material.opacity = selectedOpacity; // Use slider value for selected/connected
                        this.hoveredSprite.material.depthTest = false; // Keep selected items on top
                        this.hoveredSprite.position.z = this.hoveredSprite.userData.originalPosition.z + 0.1;
                        // Maintain purple stroke if this sprite is the current focused item
                        const isCurrent = currentFocusedItem && this.hoveredSprite.userData.text === (currentFocusedItem.text || currentFocusedItem.entry);
                        if (isCurrent) applyPurpleStroke(this.hoveredSprite); else removePurpleStroke(this.hoveredSprite);
                        // Keep selected scale; do not downscale here
                    } else {
                        // Return to the same opacity used when items are normally rendered
                        // Check if there are any selections - if not, use full opacity, otherwise use slider value
                        const hasAnySelections = this.selectedSprites.length > 0 || connectedSprites.size > 0;
                        const unselectedOpacity = hasAnySelections ? getOpacityValues().unselected : 1.0;
                        this.hoveredSprite.material.opacity = unselectedOpacity;
                        this.hoveredSprite.material.depthTest = true; // Normal depth testing
                        this.hoveredSprite.position.z = this.hoveredSprite.userData.originalPosition.z; // Reset Z
                        // Ensure stroke removed for unselected items
                        removePurpleStroke(this.hoveredSprite);
                        // Hide tooltip
                        this.hideTooltip();
                    }
                    
                    this.hoveredSprite = null;
                    document.body.style.cursor = 'default';
                }
            }

            onMouseClick(event) {
                // Cancel click if drag was detected
                if (this.isDragging) {
                    this.isDragging = false;
                    return;
                }
                
                // Fast check: if click Y position is in bottom 80px, it's likely the selection bar
                if (event.clientY > window.innerHeight - 80) {
                    return; // Skip 3D processing for bottom area
                }
                
                // Check if click is on the right panel containers (avoid conflict)
                const rightPanel = document.getElementById('right-panel');
                if (rightPanel) {
                    const panelRect = rightPanel.getBoundingClientRect();
                    if (event.clientX >= panelRect.left && event.clientX <= panelRect.right &&
                        event.clientY >= panelRect.top && event.clientY <= panelRect.bottom) {
                        return; // Skip 3D processing for right panel area
                    }
                }
                
                if (this.raycaster && this.textSprites.length > 0) {
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.textSprites);
                    
                    if (intersects.length > 0) {
                        const clickedSprite = intersects[0].object;
                        console.log('Clicked text:', clickedSprite.userData.text);
                        
                        // Find the full data for this sprite
                        const clickedData = this.embeddings.find(item => 
                            (item.text || item.entry) === clickedSprite.userData.text
                        );
                        
                        if (clickedData) {
                            console.log('=== CLICKED ITEM IN 3D ===');
                            console.log('Item Entry:', clickedData.entry);
                            console.log('Item ID:', clickedData.id);
                            console.log('Calling selectItemAsCurrentById for consistent behavior...');
                            console.log('===================================');
                            
                            // Use the same function as sidebar clicks for consistent behavior
                            window.selectItemAsCurrentById(clickedData.id, clickedData.entry);
                        }
                        
                        // REMOVED: Random sprite selection - now using connection-based highlighting only
                        console.log('⏱️ Random sprite selection: SKIPPED (using connection-based highlighting)');
                    }
                }
            }

            selectRandomSpritesOptimized(specificSprite = null) {
                console.log('⚠️ selectRandomSpritesOptimized is deprecated - using connection-based highlighting instead');
                return; // Exit early - this method is no longer used
                
                // Much faster selection without slow array operations
                const selectedSprites = [];
                
                if (specificSprite !== null) {
                    selectedSprites.push(specificSprite);
                    console.log('✅ Added clicked sprite to selection');
                }
                
                // Pre-calculate random indices to avoid repeated random generation
                const totalSprites = this.textSprites.length;
                const usedIndices = new Set();
                
                if (specificSprite) {
                    const specificIndex = this.textSprites.indexOf(specificSprite);
                    if (specificIndex !== -1) {
                        usedIndices.add(specificIndex);
                        console.log('✅ Found clicked sprite at index:', specificIndex);
                    }
                }
                
                // Add 3 more random sprites efficiently
                while (selectedSprites.length < 4 && selectedSprites.length < totalSprites) {
                    const randomIndex = Math.floor(Math.random() * totalSprites);
                    if (!usedIndices.has(randomIndex)) {
                        usedIndices.add(randomIndex);
                        selectedSprites.push(this.textSprites[randomIndex]);
                    }
                }

                console.log(`✅ Selected ${selectedSprites.length} sprites for geometry`);
                this.selectedSprites = selectedSprites;
                
                // DISABLED: Don't highlight random sprites anymore - only connection-based highlighting
                // console.log('🔄 Calling highlightSelectedSpritesOptimized...');
                // this.highlightSelectedSpritesOptimized();
                
                // DISABLED: Purple mesh around random points - we only want relationship lines
                // console.log('🔄 Calling drawMeshBetweenSelectedSpritesOptimized...');
                // this.drawMeshBetweenSelectedSpritesOptimized();
                
                console.log('🔄 Calling updateSelectionBar...');
                this.updateSelectionBar();
                
                // DISABLED: ASCII layer geometry sync - we only want relationship lines
                // if (typeof syncGeometryBetweenLayers === 'function') {
                //     syncGeometryBetweenLayers(selectedSprites);
                // }
                
                // Center camera on the clicked sprite
                if (specificSprite) {
                    this.centerCameraOnSprite(specificSprite);
                }
            }

            // Keep original for backwards compatibility
            selectRandomSprites(specificSprite = null) {
                return this.selectRandomSpritesOptimized(specificSprite);
            }

            highlightSelectedSpritesOptimized() {
                const selectedSet = new Set(this.selectedSprites);
                const hasSelection = this.selectedSprites.length > 0;
                
                // Track previous selection to minimize updates
                if (!this.previouslySelected) {
                    this.previouslySelected = new Set();
                }
                
                // Track previous global selection state
                const hadPreviousSelection = this.previouslySelected.size > 0;
                const selectionStateChanged = hasSelection !== hadPreviousSelection;
                
                // Arrays for batch operations
                const toReset = [];
                const toHighlight = [];
                const toFade = [];
                const toUnfade = [];
                
                // Find sprites that changed state
                this.previouslySelected.forEach(sprite => {
                    if (!selectedSet.has(sprite)) {
                        toReset.push(sprite);
                    }
                });
                
                selectedSet.forEach(sprite => {
                    if (!this.previouslySelected.has(sprite)) {
                        toHighlight.push(sprite);
                    }
                });
                
                // If selection state changed, we need to update all non-selected sprites
                if (selectionStateChanged || toReset.length > 0 || toHighlight.length > 0) {
                    this.textSprites.forEach(sprite => {
                        const isSelected = selectedSet.has(sprite);
                        const wasSelected = this.previouslySelected.has(sprite);
                        
                        if (!isSelected && !wasSelected) {
                            // Unselected sprite that might need opacity change
                            const opacityValues = getOpacityValues();
                            const targetOpacity = opacityValues.unselected;
                            
                            if (hasSelection && Math.abs(sprite.material.opacity - targetOpacity) > 0.01) {
                                toFade.push(sprite);
                            } else if (!hasSelection && Math.abs(sprite.material.opacity - targetOpacity) > 0.01) {
                                toUnfade.push(sprite);
                            }
                        }
                    });
                }
                
                // Batch operations for maximum performance
                
                // Reset previously selected (now unselected)
                toReset.forEach(sprite => {
                    // Use slider values for opacity (source of truth)
                    const opacityValues = getOpacityValues();
                    sprite.material.opacity = hasSelection ? opacityValues.unselected : opacityValues.unselected;
                    sprite.scale.copy(sprite.userData.originalScale);
                    sprite.renderOrder = 0; // Reset render order
                    sprite.material.depthTest = true; // Re-enable depth testing
                    sprite.position.z = sprite.userData.originalPosition.z; // Reset to original Z position
                    const originalColor = this.originalColors.get(sprite);
                    this.updateSpriteColor(sprite, originalColor, false);
                });
                
                // Highlight newly selected
                toHighlight.forEach(sprite => {
                    // Use current slider value for selected items opacity (source of truth)
                    const opacityValues = getOpacityValues();
                    const selectedOpacity = opacityValues.selected;
                    sprite.material.opacity = selectedOpacity;
                    sprite.renderOrder = 1000; // Render on top
                    sprite.material.depthTest = false; // Disable depth testing to always render on top
                    sprite.position.z += 0.1; // Slightly move forward in 3D space
                    if (!sprite.userData.originalScale) {
                        sprite.userData.originalScale = sprite.scale.clone();
                    }
                    // Keep original color for selected items with purple stroke
                    const originalColor = this.originalColors.get(sprite);
                    this.updateSpriteColor(sprite, originalColor, true);
                });
                
                // Fade unselected sprites when selection exists
                toFade.forEach(sprite => {
                    // Use current slider value for unselected items opacity (source of truth)
                    const opacityValues = getOpacityValues();
                    const unselectedOpacity = opacityValues.unselected;
                    sprite.material.opacity = unselectedOpacity;
                    sprite.renderOrder = 0;
                });
                
                // Unfade all sprites when no selection
                toUnfade.forEach(sprite => {
                    // Use slider value for unselected items (source of truth)
                    const opacityValues = getOpacityValues();
                    sprite.material.opacity = opacityValues.unselected;
                    sprite.renderOrder = 0;
                });
                
                // Update renderer sorting if we changed render orders
                if (toHighlight.length > 0) {
                    this.renderer.sortObjects = true;
                }
                
                // Update previous selection for next time
                this.previouslySelected = new Set(this.selectedSprites);
            }

            // Keep original for backwards compatibility
            highlightSelectedSprites() {
                return this.highlightSelectedSpritesOptimized();
            }

            drawMeshBetweenSelectedSpritesOptimized() {
                console.log('🔧 drawMeshBetweenSelectedSpritesOptimized called!');
                console.log('📊 Selected sprites count:', this.selectedSprites.length);
                
                // Remove existing mesh efficiently
                if (this.currentMesh) {
                    console.log('🗑️ Removing existing mesh');
                    this.scene.remove(this.currentMesh);
                    this.currentMesh.geometry.dispose();
                    this.currentMesh.material.dispose();
                    this.currentMesh = null;
                }

                if (this.selectedSprites.length >= 4) {
                    console.log('✅ Creating new mesh with', this.selectedSprites.length, 'sprites');
                    // Pre-allocate vertices array for performance
                    const vertices = new Array(this.selectedSprites.length);
                    for (let i = 0; i < this.selectedSprites.length; i++) {
                        vertices[i] = this.selectedSprites[i].position.clone();
                    }
                    
                    // Create wireframe material (stroke only) with anti-occlusion
                    const material = new THREE.MeshBasicMaterial({ 
                        color: 0x8b00ff, // Purple to match geometry color
                        wireframe: true,
                        transparent: true,
                        opacity: 0.8,
                        depthTest: false, // Disable depth testing so geometry is never occluded
                        depthWrite: false // Don't write to depth buffer
                    });
                    
                    // Create convex geometry with optimized vertices
                    const geometry = new ConvexGeometry(vertices);
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.renderOrder = 999; // Render before selected items but after unselected
                    
                    console.log('🎨 Created mesh:', mesh);
                    console.log('📐 Geometry vertices:', geometry.attributes.position.count);
                    
                    this.scene.add(mesh);
                    this.currentMesh = mesh;
                    
                    console.log('✅ Mesh added to scene! Scene children count:', this.scene.children.length);
                } else {
                    console.log('❌ Not enough sprites for mesh (need 4+, have', this.selectedSprites.length, ')');
                }
            }

            // Keep original for backwards compatibility
            drawMeshBetweenSelectedSprites() {
                return this.drawMeshBetweenSelectedSpritesOptimized();
            }

            onWindowResize() {
                const width = window.innerWidth;
                const height = window.innerHeight;
                
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            }

            animate() {
                if (!this.scene || !this.camera || !this.renderer) return;
                
                this.animationId = requestAnimationFrame(this.animate);
                
                // Performance monitoring
                if (!this.lastTime) this.lastTime = performance.now();
                const now = performance.now();
                const frameTime = now - this.lastTime;
                this.lastTime = now;
                
                // Log performance occasionally
                if (Math.floor(now / 1000) !== Math.floor((now - frameTime) / 1000)) {
                    const fps = Math.round(1000 / frameTime);
                    console.log(`🚀 FPS: ${fps}, Frame time: ${frameTime.toFixed(1)}ms`);
                }
                
                // Auto-orbit when enabled
                if (this.autoOrbitEnabled && this.controls) {
                    this.controls.autoRotate = true;
                    this.controls.autoRotateSpeed = this.autoOrbitSpeed * 60; // Convert to degrees per second
                } else {
                    this.controls.autoRotate = false;
                }
                
                // Update controls only every other frame in low-power mode
                if (!this.lowPowerMode || (this.frameCounter++ % 2 === 0)) {
                    this.controls.update();
                }
                
                // Note: Distance-compensated scaling disabled for uniform selection
                // Scaling is now only applied once after camera focus completes
                // this.updateDistanceCompensatedScaling() is called manually when needed
                
                // Frustum culling for performance - reduced frequency
                if (this.animationId % 3 === 0) { // Only every 3rd frame
                this.cameraMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse);
                this.frustum.setFromProjectionMatrix(this.cameraMatrix);
                
                // Show/hide sprites based on frustum
                this.textSprites.forEach(sprite => {
                    sprite.visible = this.frustum.containsPoint(sprite.position);
                });
                }
                
                // Sync ASCII layer rotation with text constellation (if ASCII render function exists)
                if (typeof render === 'function') {
                    render(); // This handles the ASCII background rendering
                }
                
                // Throttle render in low-power mode
                if (this.lowPowerMode) {
                    const nowRender = performance.now();
                    if (nowRender - this.lastRenderTime < this.minFrameMs) {
                        return;
                    }
                    this.lastRenderTime = nowRender;
                }
                this.renderer.render(this.scene, this.camera);
            }

            start() {
                if (!this.scene) {
                    console.error('Scene not initialized');
                    return;
                }
                this.animate();
            }

            stop() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            dispose() {
                this.stop();
                
                // Clean up mesh
                if (this.currentMesh) {
                    this.scene.remove(this.currentMesh);
                    this.currentMesh.geometry.dispose();
                    this.currentMesh.material.dispose();
                    this.currentMesh = null;
                }
                
                // Clean up sprites
                this.textSprites.forEach(sprite => {
                    this.scene.remove(sprite);
                    if (sprite.material.map) {
                        sprite.material.map.dispose();
                    }
                    sprite.material.dispose();
                });
                this.textSprites = [];
                this.selectedSprites = [];
                
                // Clean up renderer
                if (this.renderer) {
                    this.container.removeChild(this.renderer.domElement);
                    this.renderer.dispose();
                }
                
                // Remove event listeners
                window.removeEventListener('mousemove', this.onMouseMove);
                window.removeEventListener('mousedown', this.onMouseDown);
                window.removeEventListener('mouseup', this.onMouseUp);
                window.removeEventListener('click', this.onMouseClick);
                window.removeEventListener('resize', this.onWindowResize);
            }

            async init() {
                await this.loadEmbeddings();
                this.setupScene();
                this.createTextConstellation();
                
                // Position camera to see the data
                if (this.textSprites.length > 0) {
                    // Compute centroid of sprite positions for a visually balanced center
                    const centroid = new THREE.Vector3();
                    this.textSprites.forEach(sprite => centroid.add(sprite.position));
                    centroid.multiplyScalar(1 / this.textSprites.length);

                    // Compute a bounding-sphere radius from centroid for distance fit
                    let maxDistanceFromCentroid = 0;
                    this.textSprites.forEach(sprite => {
                        const d = centroid.distanceTo(sprite.position);
                        if (d > maxDistanceFromCentroid) maxDistanceFromCentroid = d;
                    });

                    const fov = this.camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDistanceFromCentroid / Math.tan(fov / 2));

                    const isMobile = window.innerWidth <= 768;
                    const distanceFitFactor = isMobile ? 1.25 : 0.9; // mobile slightly farther, desktop slightly closer
                    cameraZ *= distanceFitFactor;

                    // Place camera on Z axis aligned with centroid so content is properly centered
                    this.camera.position.copy(new THREE.Vector3(centroid.x, centroid.y, centroid.z + cameraZ));
                    this.camera.lookAt(centroid);
                    this.controls.target.copy(centroid);
                    this.controls.update();
                }
                
                console.log('Text Constellation initialized');
            }
        }

        // Global text constellation instance
        let textConstellation;
        
        // Synchronize geometry between ASCII and text layers
        function syncGeometryBetweenLayers(selectedSprites) {
            if (currentView === '3d' && selectedSprites && selectedSprites.length >= 4) {
                // Convert text constellation sprites to ASCII layer format
                selectedPoints = selectedSprites.map(sprite => ({
                    x: sprite.position.x,
                    y: sprite.position.y,
                    z: sprite.position.z
                }));
                
                // Update ASCII layer geometry to match
                drawMeshBetweenSelectedPoints();
                
                // Apply current slider opacity to the new ASCII geometry
                const asciiShapeSlider = document.getElementById('ascii-shape-opacity');
                if (asciiShapeSlider && currentMesh && currentMesh.material) {
                    const opacity = asciiShapeSlider.value / 100;
                    currentMesh.material.opacity = opacity;
                    currentMesh.material.needsUpdate = true;
                }
                
                // Also update ASCII point highlighting
                const selectedIndices = selectedSprites.map(sprite => {
                    // Find matching point in ASCII layer data
                    return pointData.findIndex(point => 
                        Math.abs(point.x - sprite.position.x) < 0.001 &&
                        Math.abs(point.y - sprite.position.y) < 0.001 &&
                        Math.abs(point.z - sprite.position.z) < 0.001
                    );
                }).filter(index => index !== -1);
                
                if (selectedIndices.length > 0) {
                    highlightSelectedPoints(selectedIndices);
                }
                
                // Apply current slider opacity to ASCII text sprites using centralized system
                if (typeof updateAllAsciiOpacities === 'function') {
                    updateAllAsciiOpacities();
                }
            }
        }

        // View switching functionality
        function switchView(viewType) {
            const asciiBackground = document.getElementById('ascii-background');
            const textConstellationElement = document.getElementById('text-constellation');
            const buttons = document.querySelectorAll('.view-btn');
            const info = document.getElementById('info');
            const selectionBar = document.getElementById('selection-bar');
            
            // Safety check - return early if essential elements don't exist
            if (!buttons.length) {
                return;
            }
            
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.view === viewType) {
                    btn.classList.add('active');
                }
            });

            if (viewType === '3d') {
                currentView = '3d';
                // Show ASCII background behind text constellation
                if (asciiBackground) asciiBackground.style.display = 'block';
                if (textConstellationElement) textConstellationElement.style.display = 'block';
                
                // Show overlays for ASCII view
                if (info) info.style.display = 'block';
                if (selectionBar) selectionBar.style.display = 'flex'; // Keep selection bar for text interactions
                
                // Show floating text entries for ASCII view
                document.querySelectorAll('.entry').forEach(entry => {
                    entry.style.display = 'block';
                });
                
                // Start both animations
                if (typeof animate === 'function') {
                    animate();
                }
                textConstellation.start();
            } else if (viewType === 'text') {
                currentView = 'text';
                // Hide ASCII background, show only text constellation
                if (asciiBackground) asciiBackground.style.display = 'none';
                if (textConstellationElement) textConstellationElement.style.display = 'block';
                
                // Hide overlays for text constellation view
                if (info) info.style.display = 'none';
                if (selectionBar) selectionBar.style.display = 'flex';
                
                // Hide floating text entries for text constellation view
                document.querySelectorAll('.entry').forEach(entry => {
                    entry.style.display = 'none';
                });
                
                textConstellation.start();
            }
        }

        async function init() {
            const container = document.querySelector('body');
            const width = window.innerWidth;
            const height = window.innerHeight;

            // Step 1: Initialize renderer and effects
            updateLoadingProgress(1, 'Initializing renderer...');

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(width, height);

            effect = new AsciiEffect(renderer, ' ■', { invert: true });
            effect.setSize(width, height);
            
            // Append ASCII effect to the background layer
            const asciiBackground = document.getElementById('ascii-background');
            asciiBackground.appendChild(effect.domElement);
            
            setTimeout(() => {
                const currentWidth = window.innerWidth;
                const currentHeight = window.innerHeight;
                effect.setSize(currentWidth, currentHeight);
                if (scene && camera) {
                    effect.render(scene, camera);
                }
            }, 100);

            // Step 2: Setup scene and camera
            updateLoadingProgress(2, 'Setting up scene...');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, width / height, 1, 1000);
            camera.position.z = 40;

            const light = new THREE.PointLight(0xffffff, 1.5);
            light.position.set(500, 500, 500);
            scene.add(light);

            const light2 = new THREE.PointLight(0xffffff, 0.25);
            light2.position.set(-500, -500, -500);
            scene.add(light2);

            // Step 3: Load data and create geometry
            updateLoadingProgress(3, 'Loading data...');
            try {
                const embeddings = await loadEmbeddings();
                createTextSpritesForASCII(embeddings);
                console.log('ASCII sprites created successfully');
            } catch (error) {
                console.error('Error creating ASCII sprites:', error);
            }

            // Calculate bounding box from ASCII text sprites
            const boundingBox = new THREE.Box3();
            if (asciiTextSprites && asciiTextSprites.length > 0) {
                asciiTextSprites.forEach(sprite => {
                    if (sprite) {
                        boundingBox.expandByObject(sprite);
                    }
                });
            }
            
            // Fallback if no sprites or empty bounding box
            if (boundingBox.isEmpty()) {
                boundingBox.setFromCenterAndSize(new THREE.Vector3(0, 0, 0), new THREE.Vector3(50, 50, 50));
            }
            
            const center = boundingBox.getCenter(new THREE.Vector3());
            const size = boundingBox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            
            const isMobile = window.innerWidth <= 768;
            const distanceFitFactor = isMobile ? 1.25 : 0.9; // keep mobile slightly farther, desktop slightly closer
            cameraZ *= distanceFitFactor; // start closer instead of far away
            
            camera.position.z = cameraZ;
            camera.lookAt(center);

            controls = new OrbitControls(camera, effect.domElement);
            controls.enableZoom = true;
            
            // Allow flexible camera distance for better navigation  
            controls.minDistance = 0.5;  // Allow very close inspection (ASCII can handle it)
            controls.maxDistance = 1000; // Allow wide overview
            
            // Better touch controls for pinch-to-zoom
            controls.touches = {
                ONE: THREE.TOUCH.ROTATE,
                TWO: THREE.TOUCH.DOLLY_PAN
            };
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            
            // More powerful zoom/pinch
            controls.zoomSpeed = 2.0; // Much faster zoom
            controls.panSpeed = 1.5; // Faster panning
            
            // Auto-orbit pause on interaction
            controls.addEventListener('start', () => {
                autoOrbitEnabled = false;
            });
            controls.addEventListener('end', () => {
                setTimeout(() => {
                    autoOrbitEnabled = true;
                }, 2000); // Resume auto-orbit after 2 seconds of inactivity
            });
            // Mark ASCII as needing re-render on any camera/controls change
            controls.addEventListener('change', () => { needsAsciiRender = true; });
            
            controls.update();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('click', onMouseClick, false);
            
            // Prevent text selection and context menu during dragging
            window.addEventListener('selectstart', (e) => e.preventDefault(), false);
            window.addEventListener('dragstart', (e) => e.preventDefault(), false);
            window.addEventListener('contextmenu', (e) => e.preventDefault(), false);

            onWindowResize();

            renderHeader();

            try {
                // Only initialize text constellation if we're in the main index page
                const textConstellationElement = document.getElementById('text-constellation');
                if (textConstellationElement) {
                // Create text constellation instance after DOM is ready
                textConstellation = new TextConstellation();
                
                // Initialize text constellation
                await textConstellation.init();
                
                console.log('Text constellation initialized successfully');
                
                    // Initialize unified view - both ASCII and text always visible
                    const asciiBackground = document.getElementById('ascii-background');
                    const textConstellationElement = document.getElementById('text-constellation');
                    const info = document.getElementById('info');
                    const selectionBar = document.getElementById('selection-bar');
                    
                    // Show both ASCII and text by default
                    if (asciiBackground) asciiBackground.style.display = 'block';
                    if (textConstellationElement) textConstellationElement.style.display = 'block';
                    if (info) info.style.display = 'block';
                    if (selectionBar) selectionBar.style.display = 'flex';
                    
                    // Show floating ASCII entries by default
                    document.querySelectorAll('.entry').forEach(entry => {
                        entry.style.display = 'block';
                    });
                    
                    // Start text constellation animation
                    textConstellation.start();
                    console.log('Text constellation animation started');
                }
            } catch (error) {
                console.error('Error initializing text constellation:', error);
            }
        }

        function onWindowResize() {
            const width = window.innerWidth;
            const height = window.innerHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
            effect.setSize(width, height);
            
            if (effect && scene && camera) {
                needsAsciiRender = true;
                effect.render(scene, camera);
                lastAsciiRenderTime = performance.now();
            }
        }

        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMouseClick(event) {
            // ASCII layer is non-interactive - all interactions handled by text constellation
            // No ASCII click detection to prevent gesture conflicts
        }

        // Animation now handled entirely by TextConstellation - no separate loop needed

        function render() {
            const timer = Date.now() - start;

            // Sync ASCII layer rotation with text constellation
            if (textConstellation && textConstellation.controls && controls) {
                // Copy rotation from text constellation to ASCII background
                camera.position.copy(textConstellation.camera.position);
                camera.rotation.copy(textConstellation.camera.rotation);
                controls.target.copy(textConstellation.controls.target);
            }

            // Auto-orbit when enabled (synchronize both layers)
            if (autoOrbitEnabled && controls) {
                controls.autoRotate = true;
                controls.autoRotateSpeed = autoOrbitSpeed * 60; // Convert to degrees per second
            } else {
                controls.autoRotate = false;
            }

            // Update controls for ASCII background
            controls.update();
            
            // Event-driven + throttled ASCII render
            const now = performance.now();
            if (!document.hidden && ((needsAsciiRender && now - lastAsciiRenderTime >= asciiTargetMs) || (now - lastAsciiRenderTime >= asciiIdleMs))) {
                effect.render(scene, camera);
                lastAsciiRenderTime = now;
                needsAsciiRender = false;
            }
        }

        function pointToScreenPosition(point, camera) {
            const vector = point.clone().project(camera);
            const halfWidth = window.innerWidth / 2;
            const halfHeight = window.innerHeight / 2;

            vector.x = (vector.x * halfWidth) + halfWidth;
            vector.y = -(vector.y * halfHeight) + halfHeight;
            return vector;
        }

        // Initialize global opacity values
        window.unselectedAsciiOpacity = 0.12; // Default for unselected ASCII (barely visible)
        window.selectedAsciiOpacity = 1.0;   // Default for selected ASCII

        // Opacity control functionality
        function initOpacityControls() {
            const selectedTextSlider = document.getElementById('selected-text-opacity');
            const unselectedTextSlider = document.getElementById('unselected-text-opacity');
            const asciiToggle = document.getElementById('ascii-toggle');
            // Optional display elements (may not exist)
            const selectedTextValue = document.getElementById('selected-text-value');
            const unselectedTextValue = document.getElementById('unselected-text-value');
            const asciiShapeValue = document.getElementById('ascii-shape-opacity-value');
            const asciiPointsValue = document.getElementById('ascii-points-opacity-value');
            const selectedAsciiValue = document.getElementById('selected-ascii-opacity-value');
            
            // Helper function to update opacity
            function updateSelectedTextOpacity(value) {
                const opacity = value / 100;
                if (selectedTextValue) selectedTextValue.textContent = value + '%';
                
                if (textConstellation && textConstellation.selectedSprites) {
                    textConstellation.selectedSprites.forEach(sprite => {
                        sprite.material.opacity = opacity;
                    });
                }
            }
            
            function updateAsciiShapeOpacity(value) {
                const opacity = value / 100;
                if (asciiShapeValue) asciiShapeValue.textContent = value + '%';
                
                if (currentMesh && currentMesh.material) {
                    currentMesh.material.opacity = opacity;
                    currentMesh.material.needsUpdate = true;
                }
            }
            
            function updateAsciiPointsOpacity(value) {
                const opacity = value / 100;
                if (asciiPointsValue) asciiPointsValue.textContent = value + '%';
                
                // Store the value for unselected sprites and trigger a full update
                window.unselectedAsciiOpacity = opacity;
                
                // Only update if the function exists and sprites are ready
                if (typeof updateAllAsciiOpacities === 'function' && asciiTextSprites && asciiTextSprites.length > 0) {
                    updateAllAsciiOpacities();
                }
            }
            
            function updateSelectedAsciiOpacity(value) {
                const opacity = value / 100;
                if (selectedAsciiValue) selectedAsciiValue.textContent = value + '%';
                
                // Store the value for selected sprites and trigger a full update
                window.selectedAsciiOpacity = opacity;
                
                // Only update if the function exists and sprites are ready
                if (typeof updateAllAsciiOpacities === 'function' && asciiTextSprites && asciiTextSprites.length > 0) {
                    updateAllAsciiOpacities();
                }
            }
            
            function updateAllAsciiOpacities() {
                // Get current values or defaults
                const unselectedOpacity = window.unselectedAsciiOpacity || 0.12;
                const selectedOpacity = window.selectedAsciiOpacity || 1.0;
                
                // Safety check - make sure everything exists
                if (!asciiTextSprites || !Array.isArray(asciiTextSprites) || asciiTextSprites.length === 0) {
                    return; // Exit early if sprites aren't ready
                }
                
                if (!pointData || !Array.isArray(pointData) || pointData.length === 0) {
                    return; // Exit early if point data isn't ready
                }
                
                try {
                    asciiTextSprites.forEach((sprite, index) => {
                        // Safety check for valid sprite and index
                        if (!sprite || !sprite.material || index >= pointData.length) {
                            return;
                        }
                        
                        // Check if this sprite is currently selected using pointData
                        const point = pointData[index];
                        const isSelected = selectedPoints && selectedPoints.length > 0 && 
                            selectedPoints.some(selectedPoint => 
                                point && selectedPoint &&
                                Math.abs(point.x - selectedPoint.x) < 0.001 &&
                                Math.abs(point.y - selectedPoint.y) < 0.001 &&
                                Math.abs(point.z - selectedPoint.z) < 0.001
                            );
                        
                        sprite.material.opacity = isSelected ? selectedOpacity : unselectedOpacity;
                        if (sprite.material.needsUpdate !== undefined) {
                            sprite.material.needsUpdate = true;
                        }
                    });
                } catch (error) {
                    console.error('Error updating ASCII opacities:', error);
                }
            }
            
            function updateUnselectedTextOpacity(value) {
                const opacity = value / 100;
                unselectedTextValue.textContent = value + '%';
                
                if (textConstellation && textConstellation.textSprites) {
                    textConstellation.textSprites.forEach(sprite => {
                        // Only update unselected sprites
                        if (!textConstellation.selectedSprites || !textConstellation.selectedSprites.includes(sprite)) {
                            sprite.material.opacity = opacity;
                        }
                    });
                }
            }
            
            // Enhanced event listeners for better slider responsiveness
            if (selectedTextSlider) {
                ['input', 'change', 'mousemove', 'touchmove'].forEach(eventType => {
                    selectedTextSlider.addEventListener(eventType, (e) => {
                        if (e.type === 'mousemove' && e.buttons !== 1) return; // Only on drag
                        updateSelectedTextOpacity(e.target.value);
                    });
                });
            }
            
            if (unselectedTextSlider) {
                ['input', 'change', 'mousemove', 'touchmove'].forEach(eventType => {
                    unselectedTextSlider.addEventListener(eventType, (e) => {
                        if (e.type === 'mousemove' && e.buttons !== 1) return; // Only on drag
                        updateUnselectedTextOpacity(e.target.value);
                    });
                });
            }
            
            // ASCII background toggle button (optional)
            if (asciiToggle) {
            asciiToggle.addEventListener('click', () => {
                const isEnabled = asciiToggle.dataset.enabled === 'true';
                const newState = !isEnabled;
                
                asciiToggle.dataset.enabled = newState.toString();
                asciiToggle.textContent = newState ? 'ON' : 'OFF';
                
                toggleAsciiBackground(newState);
            });
            }
            // Initialize ASCII background to ON by default
            toggleAsciiBackground(true);
            
            // Text constellation geometry toggle button
            const textGeometryToggle = document.getElementById('text-geometry-toggle');
            if (textGeometryToggle) {
            textGeometryToggle.addEventListener('click', () => {
                const isEnabled = textGeometryToggle.dataset.enabled === 'true';
                const newState = !isEnabled;
                
                textGeometryToggle.dataset.enabled = newState.toString();
                textGeometryToggle.textContent = newState ? 'ON' : 'OFF';
                
                toggleTextGeometry(newState);
            });
            }
            
            // ASCII geometry toggle button
            const asciiGeometryToggle = document.getElementById('ascii-geometry-toggle');
            if (asciiGeometryToggle) {
            asciiGeometryToggle.addEventListener('click', () => {
                const isEnabled = asciiGeometryToggle.dataset.enabled === 'true';
                const newState = !isEnabled;
                
                asciiGeometryToggle.dataset.enabled = newState.toString();
                asciiGeometryToggle.textContent = newState ? 'ON' : 'OFF';
                
                toggleAsciiGeometry(newState);
            });
            }
            
            // Initialize ASCII geometry to ON by default
            toggleAsciiGeometry(true);
        }

        // Book colors for reference containers (using existing getBookColor function from above)

        function updateRightPanel(focusedItem, allConnectedItems = null) {
            const startTime = performance.now();
            console.log('📋 updateRightPanel started');
            
            currentFocusedItem = focusedItem;
            
            // Start/stop distance monitoring based on focused item
            if (focusedItem) {
                startDistanceMonitoring();
            } else {
                stopDistanceMonitoring();
                // Clear connected sprites when no item is focused
                connectedSprites.clear();
            }
            
            // Update containers
            const containerStart = performance.now();
            const fromBookContainer = document.getElementById('from-book-container');
            const itemInfoContainer = document.getElementById('item-info-container');
            const bookTitleEl = document.getElementById('current-item-book-title');
            const bookAuthorEl = document.getElementById('current-item-book-author');
            const containerEnd = performance.now();
            console.log(`⏱️ DOM element access took: ${(containerEnd - containerStart).toFixed(2)}ms`);
            
            if (focusedItem) {
                // Show containers
                const showStart = performance.now();
                fromBookContainer.style.display = 'block';
                itemInfoContainer.style.display = 'block';
                const showEnd = performance.now();
                console.log(`⏱️ show containers took: ${(showEnd - showStart).toFixed(2)}ms`);
                
                // Update book info
                const bookStart = performance.now();
                const bookColor = getBookColor(focusedItem.citation.title);
                if (bookTitleEl) {
                    bookTitleEl.textContent = focusedItem.citation.title || '';
                    bookTitleEl.style.color = bookColor;
                }
                if (bookAuthorEl) {
                    bookAuthorEl.textContent = focusedItem.citation.author ? focusedItem.citation.author : '';
                }
                const bookEnd = performance.now();
                console.log(`⏱️ book info update took: ${(bookEnd - bookStart).toFixed(2)}ms`);
                
                // Update more from same book
                const sameBookStart = performance.now();
                updateSameBookEntries(focusedItem);
                const sameBookEnd = performance.now();
                console.log(`⏱️ same book entries took: ${(sameBookEnd - sameBookStart).toFixed(2)}ms`);

                // Update other books panel
                const otherBookStart = performance.now();
                updateOtherBookEntries(focusedItem);
                const otherBookEnd = performance.now();
                console.log(`⏱️ other book entries took: ${(otherBookEnd - otherBookStart).toFixed(2)}ms`);
                
                // Update book cover
                const coverStart = performance.now();
                updateBookCover(focusedItem);
                const coverEnd = performance.now();
                console.log(`⏱️ book cover update took: ${(coverEnd - coverStart).toFixed(2)}ms`);
                
                // Update hierarchical reference tree
                const treeStart = performance.now();
                updateReferenceTree(focusedItem, allConnectedItems);
                const treeEnd = performance.now();
                console.log(`⏱️ reference tree update took: ${(treeEnd - treeStart).toFixed(2)}ms`);
            } else {
                // Hide containers
                fromBookContainer.style.display = 'none';
                itemInfoContainer.style.display = 'none';
                
                // Clear data
                updateBookCover(null);
                updateReferenceTree(null);
            }
            
            const totalTime = performance.now() - startTime;
            console.log(`⏱️ TOTAL updateRightPanel took: ${totalTime.toFixed(2)}ms`);
        }
        
        function updateBookCover(focusedItem) {
            const bookCoverImage = document.getElementById('current-item-cover-image');
            
            if (!focusedItem || !focusedItem.citation) {
                if (bookCoverImage) {
                    bookCoverImage.style.display = 'none';
                }
                return;
            }
            
            const bookTitleText = focusedItem.citation.title;
            const coverUrl = BOOK_COVERS[bookTitleText];
            
            if (coverUrl && bookCoverImage) {
                bookCoverImage.src = coverUrl;
                bookCoverImage.style.display = 'block';
                bookCoverImage.onerror = () => {
                    bookCoverImage.style.display = 'none';
                };
            } else if (bookCoverImage) {
                bookCoverImage.style.display = 'none';
            }
        }
        
        function updateReferenceTree(focusedItem, allConnectedItems = null) {
            const treeContainer = document.getElementById('reference-tree');
            if (!treeContainer) return;
            
            if (!focusedItem) {
                treeContainer.innerHTML = '';
                return;
            }
            
            let treeHTML = '';
            
            // Removed Parent Index section per design simplification
            
            // Parent item section (blue) - render detailed Parent section immediately after Parent Index
            if (focusedItem.parent_text && focusedItem.parent_text.text) {
                treeHTML += createReferenceSection('Parent', 'tree-parent', [focusedItem.parent_text], 1, PANEL_LEVELS);
            }

            // Current selected item (highlighted) - Level 0 (below Parent sections)
            const safeCurrentText = focusedItem.entry.replace(/'/g, "\\'");
            treeHTML += `
                <div class="tree-section tree-current">
                    <div class="tree-section-label">Selected</div>
                    <div class="tree-item tree-current-item${focusedItem.parent_text ? ' tree-indented' : ''}">
                        <div class="tree-item-content">
                            <div class="tree-item-text" onclick="console.log('CLICK: Current selection text'); selectItemAsCurrentById('${focusedItem.id}', '${safeCurrentText}')">${focusedItem.entry}</div>
                            <div class="tree-item-actions"></div>
                        </div>
                    </div>
                </div>
            `;
            
            // All Connected Items section: show only children of the focused item
            if (focusedItem.children && focusedItem.children.length > 0) {
                treeHTML += `
                    <div class="tree-section">
                        <div class="tree-section-label">Children (${focusedItem.children.length})</div>
                        <div class="tree-nested">
                `;
                // Render each child, using full entry when available
                focusedItem.children.forEach(childRef => {
                    const childItem = findItemById(childRef.id, childRef.text);
                    const displayText = (childItem && childItem.entry) ? childItem.entry : (childRef.text || '');
                    const safeText = displayText.replace(/'/g, "\\'");
                    const truncatedText = displayText.length > 60 ? displayText.substring(0, 60) + '...' : displayText;
                    treeHTML += `
                        <div class="tree-item tree-children${(childItem && childItem.type === 'subentry') ? ' tree-indented' : ''}">
                            <div class="tree-item-content">
                                <div class="tree-item-text" onclick="selectItemAsCurrentById('${childRef.id}', '${safeText}')" title="${displayText}">${truncatedText}</div>
                                <div class="tree-item-actions"></div>
                            </div>
                        </div>
                    `;
                });
                treeHTML += `
                        </div>
                    </div>
                `;
            }

            // See also references section (orange)
            if (focusedItem.see_also && focusedItem.see_also.length > 0) {
                treeHTML += createReferenceSection('See Also', 'tree-see-also', focusedItem.see_also, 1, PANEL_LEVELS);
            }

            // See references section (green) - place after See Also per new order
            if (focusedItem.see && focusedItem.see.length > 0) {
                treeHTML += createReferenceSection('See', 'tree-see', focusedItem.see, 1, PANEL_LEVELS);
            }
            
            /* Former All Connected Items block removed from here (now shown above) */
            
            treeContainer.innerHTML = treeHTML;
        }
        
        function createReferenceSection(sectionTitle, sectionClass, references, currentLevel, maxLevel = PANEL_LEVELS) {
            if (currentLevel > maxLevel || !references || references.length === 0) {
                return '';
            }
            
            let sectionHTML = `
                <div class="tree-section ${sectionClass}">
                    <div class="tree-section-label">${sectionTitle}</div>
            `;
            
            references.forEach(ref => {
                // Determine display text. For Children, prefer full entry (with page numbers)
                let displayText = ref.text;
                if (sectionClass === 'tree-children') {
                    const fullChild = findItemById(ref.id, ref.text);
                    if (fullChild && fullChild.entry) {
                        displayText = fullChild.entry;
                    }
                }
                const safeText = displayText.replace(/'/g, "\\'");
                sectionHTML += `
                    <div class="tree-item">
                        <div class="tree-item-content">
                            <div class="tree-item-text" onclick="selectItemAsCurrentById('${ref.id}', '${safeText}')">${displayText}</div>
                            <div class="tree-item-actions"></div>
                        </div>
                    </div>
                `;
                
                // Add nested references for this item
                if (currentLevel < maxLevel) {
                    const nestedItem = findItemById(ref.id, ref.text);
                    if (nestedItem) {
                        sectionHTML += '<div class="tree-nested">';
                        
                        // Level 2: Show parent of this reference
                        if (nestedItem.parent_text && nestedItem.parent_text.text) {
                            sectionHTML += createSubReference('Parent', 'tree-parent', [nestedItem.parent_text], currentLevel + 1, maxLevel);
                        }
                        
                        // Level 2: Show see references of this item
                        if (nestedItem.see && nestedItem.see.length > 0) {
                            sectionHTML += createSubReference('See', 'tree-see', nestedItem.see.slice(0, 3), currentLevel + 1, maxLevel);
                        }
                        
                        // Level 2: Show see also references of this item
                        if (nestedItem.see_also && nestedItem.see_also.length > 0) {
                            sectionHTML += createSubReference('See Also', 'tree-see-also', nestedItem.see_also.slice(0, 3), currentLevel + 1, maxLevel);
                        }
                        
                        sectionHTML += '</div>';
                    }
                }
            });
            
            sectionHTML += '</div>';
            return sectionHTML;
        }
        
        function createSubReference(refType, refClass, references, currentLevel, maxLevel) {
            if (currentLevel > maxLevel || !references || references.length === 0) {
                return '';
            }
            
            let subHTML = `<div class="tree-sub-section"><span class="tree-sub-label">${refType}:</span></div>`;
            
            references.forEach(ref => {
                const safeText = ref.text.replace(/'/g, "\\'");
                subHTML += `
                    <div class="tree-item ${refClass}">
                        <div class="tree-item-content">
                            <div class="tree-item-text" onclick="selectItemAsCurrentById('${ref.id}', '${safeText}')">${ref.text}</div>
                            <div class="tree-item-actions"></div>
                        </div>
                    </div>
                `;
                
                // Level 3: Add one more level of nesting if available
                if (currentLevel < maxLevel) {
                    const deepNestedItem = findItemById(ref.id, ref.text);
                    if (deepNestedItem) {
                        subHTML += '<div class="tree-nested tree-deep">';
                        
                        // Only show a limited set at level 3 to avoid clutter
                        if (deepNestedItem.see && deepNestedItem.see.length > 0) {
                            deepNestedItem.see.slice(0, 2).forEach(deepRef => {
                                const deepSafeText = deepRef.text.replace(/'/g, "\\'");
                                subHTML += `
                                    <div class="tree-item tree-see">
                                        <div class="tree-item-content">
                                            <div class="tree-item-text" onclick="selectItemAsCurrentById('${deepRef.id}', '${deepSafeText}')">${deepRef.text}</div>
                                            <div class="tree-item-actions"></div>
                                        </div>
                                    </div>
                                `;
                            });
                        }
                        
                        subHTML += '</div>';
                    }
                }
            });
            
            return subHTML;
        }
        


        
        // Note: searchAndSelectItemById is defined later in the file with more comprehensive implementation
        


        function updateSeeReferences(item) {
            const container = document.getElementById('see-container');
            const itemsContainer = document.getElementById('see-items');
            
            // Check if containers exist (they may have been removed)
            if (!container || !itemsContainer) {
                return;
            }
            
            // Always show the container
            container.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            if (item.see && item.see.length > 0) {
                item.see.forEach(seeRef => {
                    const clickableItem = document.createElement('div');
                    clickableItem.className = 'clickable-item see-item'; // Add green color coding
                    // seeRef is an object with id, type, text properties like parent_text
                    clickableItem.textContent = seeRef.text || seeRef.id || 'Unknown reference';
                    clickableItem.onclick = () => searchAndSelectItemById(seeRef.id, seeRef.text);
                    itemsContainer.appendChild(clickableItem);
                });
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No see references';
                itemsContainer.appendChild(noItems);
            }
        }

        function updateSeeAlsoReferences(item) {
            const container = document.getElementById('see-also-container');
            const itemsContainer = document.getElementById('see-also-items');
            
            // Check if containers exist (they may have been removed)
            if (!container || !itemsContainer) {
                return;
            }
            
            // Always show the container
            container.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            if (item.see_also && item.see_also.length > 0) {
                item.see_also.forEach(seeAlsoRef => {
                    const clickableItem = document.createElement('div');
                    clickableItem.className = 'clickable-item see-also-item'; // Add orange color coding
                    // seeAlsoRef is an object with id, type, text properties like parent_text
                    clickableItem.textContent = seeAlsoRef.text || seeAlsoRef.id || 'Unknown reference';
                    clickableItem.onclick = () => searchAndSelectItemById(seeAlsoRef.id, seeAlsoRef.text);
                    itemsContainer.appendChild(clickableItem);
                });
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No see also references';
                itemsContainer.appendChild(noItems);
            }
        }

        function updateParentItem(item) {
            const container = document.getElementById('parent-container');
            const itemsContainer = document.getElementById('parent-items');
            
            // Check if containers exist (they may have been removed)
            if (!container || !itemsContainer) {
                return;
            }
            
            // Always show the container
            container.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            if (item.parent_text && item.parent_text.text) {
                const clickableItem = document.createElement('div');
                clickableItem.className = 'clickable-item parent-item'; // Add blue color coding
                clickableItem.textContent = item.parent_text.text;
                clickableItem.onclick = () => {
                    console.log('Clicking parent item:', item.parent_text);
                    searchAndSelectItemById(item.parent_text.id, item.parent_text.text);
                };
                itemsContainer.appendChild(clickableItem);
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No parent item';
                itemsContainer.appendChild(noItems);
            }
        }

        function updateSameBookEntries(item) {
            const container = document.getElementById('same-book-container');
            const itemsContainer = document.getElementById('same-book-items');
            
            // Always show the container
            container.style.display = 'block';
            itemsContainer.innerHTML = '';
            
            if (item && item.citation && textConstellation && textConstellation.embeddings) {
                // Find other entries from the same book, excluding the current item
                const sameBookEntries = textConstellation.embeddings.filter(entry => 
                    entry.citation.title === item.citation.title && 
                    entry.id !== item.id
                );
                
                if (sameBookEntries.length > 0) {
                    // Diversify: dedupe by text and shuffle
                    const seen = new Set();
                    const deduped = sameBookEntries.filter(e => {
                        const key = (e.entry || '').slice(0, 120);
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });
                    // Shuffle
                    for (let i = deduped.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [deduped[i], deduped[j]] = [deduped[j], deduped[i]];
                    }
                    // Sample up to 10 diverse items
                    const limitedEntries = deduped.slice(0, 10);
                    
                    limitedEntries.forEach(entry => {
                        const link = document.createElement('a');
                        link.className = 'clickable-item';
                        link.href = '#';
                        
                        // Truncate long entries for better display
                        const displayText = entry.entry.length > 60 ? 
                            entry.entry.substring(0, 57) + '...' : 
                            entry.entry;
                        
                        link.textContent = displayText;
                        link.title = entry.entry; // Full text on hover
                        link.onclick = (e) => { e.preventDefault(); searchAndSelectItemById(entry.id, entry.entry); };
                        itemsContainer.appendChild(link);
                    });
                    
                    // Add count indicator if there are more entries
                    if (deduped.length > 10) {
                        const moreIndicator = document.createElement('div');
                        moreIndicator.className = 'no-items';
                        moreIndicator.textContent = `+${deduped.length - 10} more`;
                        itemsContainer.appendChild(moreIndicator);
                    }
                } else {
                    const noItems = document.createElement('div');
                    noItems.className = 'no-items';
                    noItems.textContent = 'No other entries from this book';
                    itemsContainer.appendChild(noItems);
                }
            } else {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No data available';
                itemsContainer.appendChild(noItems);
            }
        }

        // Populate "More from other books" with random entries from different books
        function updateOtherBookEntries(item) {
            const container = document.getElementById('other-book-container');
            const itemsContainer = document.getElementById('other-book-items');
            if (!container || !itemsContainer) return;
            container.style.display = 'block';
            itemsContainer.innerHTML = '';

            if (!textConstellation || !textConstellation.embeddings || textConstellation.embeddings.length === 0) {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No data available';
                itemsContainer.appendChild(noItems);
                return;
            }

            const currentBook = item && item.citation ? item.citation.title : null;
            const pool = textConstellation.embeddings.filter(e => !currentBook || e.citation.title !== currentBook);
            if (pool.length === 0) {
                const noItems = document.createElement('div');
                noItems.className = 'no-items';
                noItems.textContent = 'No entries from other books';
                itemsContainer.appendChild(noItems);
                return;
            }

            // Dedupe by text and shuffle
            const seen = new Set();
            const deduped = pool.filter(e => {
                const key = (e.entry || '').slice(0, 120);
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
            for (let i = deduped.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deduped[i], deduped[j]] = [deduped[j], deduped[i]];
            }

            const limit = Math.min(10, deduped.length);
            const sample = deduped.slice(0, limit);
            sample.forEach(entry => {
                const link = document.createElement('a');
                link.className = 'clickable-item';
                link.href = '#';
                const displayText = entry.entry.length > 60 ? entry.entry.substring(0, 57) + '…' : entry.entry;
                link.textContent = displayText;
                link.title = entry.entry;
                link.onclick = (e) => { e.preventDefault(); searchAndSelectItemById(entry.id, entry.entry); };
                itemsContainer.appendChild(link);
            });

            if (deduped.length > limit) {
                const more = document.createElement('div');
                more.className = 'no-items';
                more.textContent = `+${deduped.length - limit} more`;
                itemsContainer.appendChild(more);
            }
        }

        function hideAllReferences() {
            // Don't hide them anymore - always show the containers
            // This function is kept for backward compatibility but doesn't hide containers
        }

        function searchAndSelectItemById(searchId, searchText) {
            console.log('🔍 Searching for item by ID:', searchId, 'Text:', searchText);
            
            // Search in text constellation first
            if (textConstellation && textConstellation.embeddings) {
                console.log('📊 Total embeddings available:', textConstellation.embeddings.length);
                
                let foundItem = textConstellation.embeddings.find(point => point.id === searchId);
                console.log('🎯 Found by ID:', foundItem ? 'YES' : 'NO');
                
                // If not found by ID, try to find by exact text match
                if (!foundItem && searchText) {
                    foundItem = textConstellation.embeddings.find(point => 
                        point.entry === searchText
                    );
                    console.log('🎯 Found by exact text match:', foundItem ? 'YES' : 'NO');
                }
                
                // If still not found, try partial text search
                if (!foundItem && searchText) {
                    foundItem = textConstellation.embeddings.find(point => {
                        return point.entry.toLowerCase().includes(searchText.toLowerCase()) ||
                               (point.parent_text && point.parent_text.text && 
                                point.parent_text.text.toLowerCase().includes(searchText.toLowerCase()));
                    });
                    console.log('🎯 Found by partial text search:', foundItem ? 'YES' : 'NO');
                }
                
                if (foundItem) {
                    console.log('✅ Found item in text constellation:', foundItem.entry);
                    // Use the comprehensive selection function that handles camera, connections, etc.
                    return window.selectItemAsCurrentById(foundItem.id, foundItem.entry);
                }
            }
            
            console.log('❌ Item not found in current dataset. ID:', searchId, 'Text:', searchText);
            alert(`Item "${searchText || searchId}" not found in current dataset. It may be in a different view or filtered out.`);
            return false;
        }

        // ASCII background toggle functionality
        function toggleAsciiBackground(enabled) {
            const asciiBackground = document.getElementById('ascii-background');
            const info = document.getElementById('info');
            
            if (asciiBackground) {
                asciiBackground.style.display = enabled ? 'block' : 'none';
            }
            
            if (info) {
                info.style.display = enabled ? 'block' : 'none';
            }
            
            // Hide/show floating ASCII entries
            document.querySelectorAll('.entry').forEach(entry => {
                entry.style.display = enabled ? 'block' : 'none';
            });
            
            console.log('ASCII background:', enabled ? 'enabled' : 'disabled');
        }

        // Fallback: ensure loading screen dismisses even if a step silently fails
        window.addEventListener('load', () => {
            setTimeout(() => {
                const loadingScreen = document.getElementById('loading-screen');
                const mainContent = document.getElementById('main-content');
                if (loadingScreen && mainContent && mainContent.style.display !== 'block') {
                    try { updateLoadingProgress(4, 'Ready to explore'); } catch (e) {}
                    try { completeLoading(); } catch (e) {}
                }
            }, 3000);
        });

        // Text constellation geometry toggle functionality
        function toggleTextGeometry(enabled) {
            console.log('🔧 Toggle Text Constellation geometry:', enabled);
            
            // Check TextConstellation geometry
            if (textConstellation && textConstellation.currentMesh) {
                textConstellation.currentMesh.visible = enabled;
                console.log('✅ TextConstellation geometry:', enabled ? 'shown' : 'hidden');
            }
            
            // If enabled but no geometry exists, regenerate it
            if (enabled) {
                if (textConstellation && textConstellation.selectedSprites && textConstellation.selectedSprites.length > 0) {
                    console.log('🔄 Regenerating TextConstellation geometry...');
                    textConstellation.drawMeshBetweenSelectedSpritesOptimized();
                }
            }
            
            console.log('Text constellation geometry toggle complete');
        }

        // ASCII geometry toggle functionality (actual ASCII layer geometry)
        function toggleAsciiGeometry(enabled) {
            console.log('🔧 Toggle ASCII layer geometry:', enabled);
            
            // Control ASCII text sprites (the actual ASCII geometry)
            if (typeof asciiTextSprites !== 'undefined' && asciiTextSprites && asciiTextSprites.length > 0) {
                asciiTextSprites.forEach(sprite => {
                    if (sprite && sprite.visible !== undefined) {
                        sprite.visible = enabled;
                    }
                });
                console.log(`✅ ASCII text sprites (${asciiTextSprites.length}):`, enabled ? 'shown' : 'hidden');
            }
            
            // Check ASCII layer convex geometry
            if (typeof currentMesh !== 'undefined' && currentMesh) {
                currentMesh.visible = enabled;
                console.log('✅ ASCII layer convex mesh:', enabled ? 'shown' : 'hidden');
            }
            
            // Check if there are any THREE.Points objects in the scene
            if (typeof scene !== 'undefined' && scene) {
                scene.traverse((object) => {
                    if (object.type === 'Points') {
                        object.visible = enabled;
                        console.log('✅ ASCII Points object:', enabled ? 'shown' : 'hidden');
                    }
                });
            }
            
            // If enabled but no geometry exists, regenerate it
            if (enabled) {
                if (typeof selectedPoints !== 'undefined' && selectedPoints && selectedPoints.length > 0) {
                    console.log('🔄 Regenerating ASCII layer convex mesh...');
                    drawMeshBetweenSelectedPoints();
                }
            }
            
            console.log('ASCII geometry toggle complete');
        }

        // Debug page detection
        console.log('INDEX.HTML SCRIPT LOADED');
        console.log('Current URL:', window.location.href);
        console.log('Current pathname:', window.location.pathname);
        
        // STRICT page detection - only run on exactly index.html, root, or 2025.html
        const isIndexPage = window.location.pathname.endsWith('index.html') || 
                           window.location.pathname === '/' || 
                           window.location.pathname.endsWith('/') ||
                           window.location.pathname.endsWith('2025.html') ||
                           (!window.location.pathname.includes('process') && !window.location.pathname.includes('.html'));
        
        // Don't run if other scripts have already claimed the page
        const otherScriptsActive = window.stopOtherAnimations;
        
        if (isIndexPage && !otherScriptsActive) {
            console.log('✅ INDEX.HTML: Initializing index scripts');
        init().then(() => {
                // DON'T call animate() here - let TextConstellation handle all animation
                // animate(); // REMOVED - this was causing duplicate animation loops
            initOpacityControls();
                console.log('✅ INDEX.HTML: Initialization complete, TextConstellation handles animation');
                
                // Set up coordinate scale slider event handler
                const coordinateScaleSlider = document.getElementById('coordinate-scale');
                const coordinateScaleValue = document.getElementById('coordinate-scale-value');
                
                if (coordinateScaleSlider && coordinateScaleValue) {
                    coordinateScaleSlider.addEventListener('input', function(e) {
                        const newScale = parseFloat(e.target.value);
                        coordinateScale = newScale;
                        coordinateScaleValue.textContent = newScale + 'x';
                        
                        console.log(`🎛️ Coordinate scale changed to: ${newScale}x`);
                        
                        // Reload both visualizations with new scale
                        if (textConstellation) {
                            console.log('🔄 Reloading text constellation with new scale...');
                            textConstellation.loadEmbeddings().then(() => {
                                // Clear existing sprites first
                                textConstellation.textSprites.forEach(sprite => {
                                    textConstellation.scene.remove(sprite);
                                    if (sprite.material.map) {
                                        sprite.material.map.dispose();
                                    }
                                    sprite.material.dispose();
                                });
                                textConstellation.textSprites = [];
                                
                                // Create new sprites with updated coordinates
                                textConstellation.embeddings.forEach((embedding, index) => {
                                    const position = new THREE.Vector3(embedding.x, embedding.y, embedding.z);
                                    // Extract clean concept text without locators for sprite display
                                    const displayText = extractCleanConcept(embedding.text || embedding.entry);
                                    const sprite = textConstellation.createTextSprite(displayText, embedding.color, position, embedding.citation, embedding.entry);
                                    textConstellation.textSprites.push(sprite);
                                    textConstellation.scene.add(sprite);
                                });
                                
                                console.log('✅ Text constellation reloaded');
                            });
                        }
                        
                        // Reload ASCII scene with new scale
                        console.log('🔄 Reloading ASCII scene with new scale...');
                        loadEmbeddings().then(embeddings => {
                            createTextSpritesForASCII(embeddings);
                            console.log('✅ ASCII scene reloaded');
                        });
                    });
                    
                    console.log('🎛️ Coordinate scale slider initialized');
                }
                
                // Set up item size scale slider event handler
                const itemSizeSlider = document.getElementById('item-size-scale');
                const itemSizeValue = document.getElementById('item-size-value');
                
                if (itemSizeSlider && itemSizeValue) {
                    itemSizeSlider.addEventListener('input', function(e) {
                        const newSize = parseFloat(e.target.value);
                        itemSizeScale = newSize;
                        itemSizeValue.textContent = newSize + 'x';
                        console.log(`🎛️ Item size scale changed to: ${newSize}x`);
                        
                        // Immediately apply new uniform scale to all currently selected items
                        if (textConstellation && !textConstellation.isCentering) {
                            textConstellation.updateDistanceCompensatedScaling();
                            console.log(`🔄 Applied new uniform scale ${newSize}x to all selected items`);
                        }
                    });
                }
                
                // Set up zoom distance slider event handler
                const zoomDistanceSlider = document.getElementById('zoom-distance');
                const zoomDistanceValue = document.getElementById('zoom-distance-value');
                
                if (zoomDistanceSlider && zoomDistanceValue) {
                    zoomDistanceSlider.addEventListener('input', function(e) {
                        const newDistance = parseFloat(e.target.value);
                        zoomDistance = newDistance;
                        zoomDistanceValue.textContent = newDistance.toString();
                        
                        // Reset base reference distance so it recalculates with new zoom distance
                        baseReferenceDistance = newDistance;
                        console.log(`🎛️ Zoom distance changed to: ${newDistance} units - base reference distance reset`);
                        
                        // Trigger recalculation for currently selected items
                        if (textConstellation && !textConstellation.isCentering) {
                            textConstellation.updateDistanceCompensatedScaling();
                        }
                    });
                }
                
                // Complete loading and show main content
                updateLoadingProgress(4, 'Ready to explore');
                completeLoading();
        });
        } else {
            console.log('❌ INDEX.HTML: Not running - either not index page or other scripts active');
            console.log('❌ INDEX.HTML: isIndexPage:', isIndexPage, 'otherScriptsActive:', otherScriptsActive);
        }

        function revealUIAfterSelection() {
            const rightPanel = document.getElementById('right-panel');
            const leftPanel = document.getElementById('left-panel');
            const title = document.getElementById('top-left-title');
            const prompt = document.getElementById('center-prompt');
            if (rightPanel) rightPanel.style.display = 'block';
            if (leftPanel) leftPanel.style.display = 'block';
            if (title) title.style.display = 'block';
            if (prompt) prompt.style.display = 'none';
            // Lazy-load How it was made images once
            if (!window.__howMadeLoaded) {
                window.__howMadeLoaded = true;
                loadHowMadeImages().then(urls => initHowMade(urls));
            }
        }

        // Populate How it was made images (auto-loads from folder)
        let HOW_MADE_IMAGES = [];
        let howMadeIndex = 0;

        async function loadHowMadeImages() {
            // Use workspace-relative path that exists under /process/
            const base = 'process/';
            const manifestUrls = [base + 'manifest.json', base + 'index.json'];
            // Try manifest first
            for (const url of manifestUrls) {
                try {
                    const res = await fetch(url, { cache: 'no-store' });
                    if (res.ok) {
                        const data = await res.json();
                        if (Array.isArray(data) && data.length) {
                            HOW_MADE_IMAGES = data.map(name => (name.startsWith('http') ? name : base + name));
                            return HOW_MADE_IMAGES;
                        }
                    }
                } catch (e) {}
            }
            // Try parsing directory listing if server provides it
            try {
                const res = await fetch(base, { cache: 'no-store' });
                if (res.ok) {
                    const html = await res.text();
                    const exts = ['png','jpg','jpeg','gif','webp','svg'];
                    const regex = /href=["']([^"']+\.(?:png|jpe?g|gif|webp|svg))["']/gi;
                    const urls = new Set();
                    let m;
                    while ((m = regex.exec(html)) !== null) {
                        let href = m[1];
                        if (!/^https?:/i.test(href)) href = base + href.replace(/^\.?\/?/, '');
                        const ext = href.split('.').pop().toLowerCase();
                        if (exts.includes(ext)) urls.add(href);
                    }
                    HOW_MADE_IMAGES = Array.from(urls);
                    return HOW_MADE_IMAGES;
                }
            } catch (e) {}
            // Fallback: return current set (possibly empty)
            return HOW_MADE_IMAGES;
        }

        function initHowMade(images = []) {
            if (Array.isArray(images) && images.length) HOW_MADE_IMAGES = images;
            const list = document.getElementById('how-made-list');
            if (!list) return;
            list.innerHTML = '';
            HOW_MADE_IMAGES.forEach(src => {
                const img = document.createElement('img');
                img.src = src;
                img.alt = 'Process image';
                img.loading = 'lazy';
                img.style.cssText = 'width:100%; border-radius:6px; cursor:pointer; object-fit:cover;';
                img.onclick = () => openGalleryBySrc(src);
                list.appendChild(img);
            });
        }

        function openGalleryBySrc(src) {
            howMadeIndex = Math.max(0, HOW_MADE_IMAGES.indexOf(src));
            openGalleryAtIndex(howMadeIndex);
        }

        function openGalleryAtIndex(idx) {
            if (!HOW_MADE_IMAGES.length) return;
            howMadeIndex = ((idx % HOW_MADE_IMAGES.length) + HOW_MADE_IMAGES.length) % HOW_MADE_IMAGES.length;
            const modal = document.getElementById('gallery-modal');
            const image = document.getElementById('gallery-image');
            if (!modal || !image) return;
            image.src = HOW_MADE_IMAGES[howMadeIndex];
            modal.style.display = 'flex';
        }

        function closeGallery() {
            const modal = document.getElementById('gallery-modal');
            if (modal) modal.style.display = 'none';
        }

        document.addEventListener('click', (e) => {
            if (e.target && e.target.id === 'gallery-close') closeGallery();
            if (e.target && e.target.id === 'gallery-modal') closeGallery();
            if (e.target && e.target.id === 'gallery-prev') openGalleryAtIndex(howMadeIndex - 1);
            if (e.target && e.target.id === 'gallery-next') openGalleryAtIndex(howMadeIndex + 1);
        });
        document.addEventListener('keydown', (e) => {
            const modal = document.getElementById('gallery-modal');
            if (!modal || modal.style.display === 'none') return;
            if (e.key === 'Escape') closeGallery();
            if (e.key === 'ArrowLeft') openGalleryAtIndex(howMadeIndex - 1);
            if (e.key === 'ArrowRight') openGalleryAtIndex(howMadeIndex + 1);
        });

        function createStrokeTextureFromSprite(sprite, strokeColor = '#8b5cf6') {
            try {
                const baseTex = sprite.userData.originalTexture;
                if (!baseTex || !baseTex.image) return null;
                const baseCanvas = baseTex.image;
                const w = baseCanvas.width, h = baseCanvas.height;
                const canvas = document.createElement('canvas');
                canvas.width = w; canvas.height = h;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(baseCanvas, 0, 0, w, h);
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 6;
                drawRoundedRectFunction(ctx, 3, 3, w - 6, h - 6, 12, false, true);
                const tex = new THREE.CanvasTexture(canvas);
                tex.needsUpdate = true;
                return tex;
            } catch (e) { console.warn('Stroke texture error', e); return null; }
        }
        
        function applyPurpleStroke(sprite) {
            if (!sprite || !sprite.material) return;
            if (!sprite.userData.strokeTexture) {
                sprite.userData.strokeTexture = createStrokeTextureFromSprite(sprite);
            }
            if (sprite.userData.strokeTexture) {
                sprite.material.map = sprite.userData.strokeTexture;
                sprite.material.needsUpdate = true;
                sprite.userData.strokeEnabled = true;
            }
        }
        
        function removePurpleStroke(sprite) {
            if (!sprite || !sprite.material) return;
            if (sprite.userData.originalTexture) {
                sprite.material.map = sprite.userData.originalTexture;
                sprite.material.needsUpdate = true;
            }
            sprite.userData.strokeEnabled = false;
        }
    </script>
    
    </div> <!-- End main-content -->
</body>

</html>
</html>